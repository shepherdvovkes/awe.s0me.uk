<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNIX/32V Terminal ~ %</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            font-family: 'IBM Plex Mono', 'Courier New', monospace;
            font-size: 16px;
            overflow: hidden;
            position: relative;
        }
        
        /* Three.js Canvas for CRT effects */
        #crt-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: none;
        }
        
        /* Startup Animation */
        .startup-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: #000;
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'IBM Plex Mono', 'Courier New', monospace;
        }
        
        .startup-text {
            color: #33ff33;
            font-size: 24px;
            text-shadow: 
                0 0 2px #33ff33,
                0 0 4px #33ff33,
                0 0 6px rgba(51, 255, 51, 0.5);
            opacity: 0;
            transform: translateY(20px);
            animation: textGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes textGlow {
            0% {
                text-shadow: 
                    0 0 2px #33ff33,
                    0 0 4px #33ff33,
                    0 0 6px rgba(51, 255, 51, 0.5);
            }
            100% {
                text-shadow: 
                    0 0 4px #33ff33,
                    0 0 8px #33ff33,
                    0 0 12px rgba(51, 255, 51, 0.8),
                    0 0 16px rgba(51, 255, 51, 0.6);
            }
        }
        
        .startup-text.visible {
            opacity: 1;
            transform: translateY(0);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .tunnel-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: #000;
            z-index: 2500;
            display: none;
            perspective: 1000px;
        }
        
        .tunnel-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
        }
        
        .tunnel-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            border: 2px solid #33ff33;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: tunnelMove 5s linear infinite;
            box-shadow: 
                0 0 10px #33ff33,
                0 0 20px rgba(51, 255, 51, 0.5),
                inset 0 0 10px rgba(51, 255, 51, 0.3);
        }
        
        @keyframes tunnelMove {
            0% {
                width: 10px;
                height: 10px;
                opacity: 1;
                transform: translate(-50%, -50%) translateZ(0px) scale(1);
            }
            50% {
                width: 500px;
                height: 500px;
                opacity: 0.8;
                transform: translate(-50%, -50%) translateZ(250px) scale(1.2);
            }
            100% {
                width: 1200px;
                height: 1200px;
                opacity: 0;
                transform: translate(-50%, -50%) translateZ(600px) scale(2);
            }
        }
        
        .tunnel-ring:nth-child(1) { animation-delay: 0s; }
        .tunnel-ring:nth-child(2) { animation-delay: 0.05s; }
        .tunnel-ring:nth-child(3) { animation-delay: 0.1s; }
        .tunnel-ring:nth-child(4) { animation-delay: 0.15s; }
        .tunnel-ring:nth-child(5) { animation-delay: 0.2s; }
        .tunnel-ring:nth-child(6) { animation-delay: 0.25s; }
        .tunnel-ring:nth-child(7) { animation-delay: 0.3s; }
        .tunnel-ring:nth-child(8) { animation-delay: 0.35s; }
        .tunnel-ring:nth-child(9) { animation-delay: 0.4s; }
        .tunnel-ring:nth-child(10) { animation-delay: 0.45s; }
        .tunnel-ring:nth-child(11) { animation-delay: 0.5s; }
        .tunnel-ring:nth-child(12) { animation-delay: 0.55s; }
        .tunnel-ring:nth-child(13) { animation-delay: 0.6s; }
        .tunnel-ring:nth-child(14) { animation-delay: 0.65s; }
        .tunnel-ring:nth-child(15) { animation-delay: 0.7s; }
        .tunnel-ring:nth-child(16) { animation-delay: 0.75s; }
        .tunnel-ring:nth-child(17) { animation-delay: 0.8s; }
        .tunnel-ring:nth-child(18) { animation-delay: 0.85s; }
        .tunnel-ring:nth-child(19) { animation-delay: 0.9s; }
        .tunnel-ring:nth-child(20) { animation-delay: 0.95s; }
        .tunnel-ring:nth-child(21) { animation-delay: 1s; }
        .tunnel-ring:nth-child(22) { animation-delay: 1.05s; }
        .tunnel-ring:nth-child(23) { animation-delay: 1.1s; }
        .tunnel-ring:nth-child(24) { animation-delay: 1.15s; }
        .tunnel-ring:nth-child(25) { animation-delay: 1.2s; }
        .tunnel-ring:nth-child(26) { animation-delay: 1.25s; }
        .tunnel-ring:nth-child(27) { animation-delay: 1.3s; }
        .tunnel-ring:nth-child(28) { animation-delay: 1.35s; }
        .tunnel-ring:nth-child(29) { animation-delay: 1.4s; }
        .tunnel-ring:nth-child(30) { animation-delay: 1.45s; }
        
        /* Login screen entrance effect */
        .login-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: #000;
            z-index: 2000;
            transform: scale(0.1);
            opacity: 0;
            transition: transform 1s ease-out, opacity 1s ease-out;
        }
        
        .login-screen.entering {
            transform: scale(1);
            opacity: 1;
        }
        .login-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: #000;
            z-index: 2000;
        }
        
        /* Autocomplete styles */
        .autocomplete-container {
            position: fixed;
            background: #000;
            border: 1px solid #33ff33;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            color: #33ff33;
            box-shadow: 
                0 0 10px rgba(51, 255, 51, 0.3),
                0 0 20px rgba(51, 255, 51, 0.1);
            min-width: 300px;
        }
        
        .autocomplete-header {
            padding: 8px 12px;
            background: #1a1a1a;
            border-bottom: 1px solid #33ff33;
            font-weight: bold;
            color: #33ff33;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .autocomplete-suggestion {
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border-right: 1px solid #1a1a1a;
            border-bottom: 1px solid #1a1a1a;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.selected {
            background: #1a3a1a;
            color: #33ff33;
        }
        
        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }
        
        /* Scrollbar for autocomplete */
        .autocomplete-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .autocomplete-container::-webkit-scrollbar-track {
            background: #000;
        }
        
        .autocomplete-container::-webkit-scrollbar-thumb {
            background: #33ff33;
            border-radius: 4px;
        }
        
        .autocomplete-container::-webkit-scrollbar-thumb:hover {
            background: #4dff4d;
        }
        
        .login-screen .terminal {
            width: 100%;
            height: 100%;
            color: #33ff33;
            font-size: 13px;
            line-height: 1.3;
            position: relative;
            z-index: 10;
            text-shadow: 
                0 0 2px #33ff33,
                0 0 4px #33ff33,
                0 0 6px rgba(51, 255, 51, 0.5);
            pointer-events: auto;
            padding: 20px;
        }
        
        .login-output {
            height: calc(100% - 100px);
            overflow-y: auto;
            margin-bottom: 20px;
            scrollbar-width: none;
            -ms-overflow-style: none;
            scroll-behavior: smooth;
        }
        
        .login-output::-webkit-scrollbar {
            display: none;
        }
        
        .login-prompt-line, .password-prompt-line {
            display: flex;
            align-items: center;
            position: relative;
            margin: 10px 0;
        }
        
        .login-prompt {
            color: #33ff33;
            margin-right: 5px;
            text-shadow: 
                0 0 2px #33ff33,
                0 0 4px #33ff33;
        }
        
        .login-input {
            background: transparent;
            border: none;
            color: #33ff33;
            font-family: inherit;
            font-size: inherit;
            outline: none;
            flex: 1;
            caret-color: #33ff33;
            text-shadow: 
                0 0 2px #33ff33,
                0 0 4px #33ff33;
        }
        
        /* Terminal container - full screen */
        .terminal-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1000px;
        }
        
        /* CRT Monitor Frame - full screen */
        .crt-monitor {
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at center, #1a1a1a 0%, #000 70%),
                linear-gradient(135deg, #333 0%, #111 50%, #000 100%);
            border-radius: 0;
            padding: 20px;
            box-shadow: 
                inset 0 0 50px rgba(0, 0, 0, 0.8),
                0 0 100px rgba(0, 0, 0, 0.9),
                0 20px 50px rgba(0, 0, 0, 0.7);
            position: relative;
            transform: none;
        }
        
        /* Curved CRT Screen - full screen */
        .crt-screen {
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse 80% 60% at 50% 40%, #002200 0%, #001100 40%, #000800 70%, #000000 100%);
            border-radius: 10px;
            padding: 20px;
            position: relative;
            overflow: hidden;
            transform: none;
            box-shadow: 
                inset 0 0 100px rgba(0, 0, 0, 0.9),
                inset 0 0 50px rgba(0, 100, 0, 0.1);
        }
        
        /* Terminal content - unified font size */
        .terminal {
            width: 100%;
            height: 100%;
            color: #33ff33;
            font-size: 16px;
            line-height: 1.4;
            position: relative;
            z-index: 10;
            text-shadow: 
                0 0 2px #33ff33,
                0 0 4px #33ff33,
                0 0 6px rgba(51, 255, 51, 0.5);
            pointer-events: auto;
        }
        
        .system-info {
            font-size: 16px;
            line-height: 1.4;
            margin-bottom: 20px;
            position: relative;
        }
        
        .system-info div {
            margin: 3px 0;
        }
        
        /* Logo container and spinning logo */
        .logo-container {
            position: fixed;
            top: 20px;
            right: 20px;
            text-align: center;
            z-index: 9999;
            pointer-events: none;
        }
        
        .pulsing-logo {
            width: 80px;
            height: 80px;
            animation: logoPulse 3s ease-in-out infinite;
            filter: drop-shadow(0 0 15px rgba(51, 255, 51, 0.9));
        }
        
        .teletype-text {
            color: #33ff33;
            font-size: 14px;
            font-weight: bold;
            margin-top: 5px;
            text-shadow: 
                0 0 5px #33ff33,
                0 0 10px rgba(51, 255, 51, 0.6);
            animation: textGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes logoPulse {
            0% {
                filter: drop-shadow(0 0 10px rgba(51, 255, 51, 0.6));
                transform: scale(1);
            }
            50% {
                filter: drop-shadow(0 0 25px rgba(51, 255, 51, 1.0));
                transform: scale(1.05);
            }
            100% {
                filter: drop-shadow(0 0 10px rgba(51, 255, 51, 0.6));
                transform: scale(1);
            }
        }
        
        .terminal-output {
            height: calc(100% - 150px);
            overflow-y: auto;
            margin-bottom: 20px;
            scrollbar-width: none;
            -ms-overflow-style: none;
            scroll-behavior: smooth;
        }
        
        .terminal-output::-webkit-scrollbar {
            display: none;
        }
        
        .output-line {
            margin: 3px 0;
            word-wrap: break-word;
        }
        
        .prompt-line {
            display: flex;
            align-items: center;
            position: relative;
            z-index: 50;
        }
        
        .prompt {
            color: #33ff33;
            margin-right: 5px;
            font-size: 16px;
            text-shadow: 
                0 0 2px #33ff33,
                0 0 4px #33ff33;
        }
        
        .command-input {
            background: transparent;
            border: none;
            color: #33ff33;
            font-family: inherit;
            font-size: 16px;
            outline: none;
            flex: 1;
            caret-color: #33ff33;
            text-shadow: 
                0 0 2px #33ff33,
                0 0 4px #33ff33;
            position: relative;
            z-index: 100;
        }
        
        .cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background: #33ff33;
            margin-left: 2px;
            animation: cursorBlink 1s infinite;
            box-shadow: 0 0 5px #33ff33;
            vertical-align: text-bottom;
        }
        
        @keyframes cursorBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .success { color: #44ff44; }
        .error { color: #ff4444; }
        .info { color: #4444ff; }
        .highlight { 
            color: #ffff44; 
            text-shadow: 0 0 3px #ffff44;
        }
        .motd { 
            color: #33ff33; 
            text-shadow: 0 0 2px #33ff33, 0 0 4px #33ff33;
            margin: 3px 0;
        }
        
        /* Matrix Follow the White Rabbit Effect */
        .matrix-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 5000;
            display: none;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            text-align: center;
            padding-top: 40vh;
        }
        
        .matrix-text {
            font-size: 24px;
            text-shadow: 0 0 10px #00ff00;
            margin-bottom: 20px;
        }
        

        
        /* CRT Power On/Off Effects */
        .crt-power-on {
            animation: crtPowerOn 2s ease-out forwards;
        }
        
        .crt-power-off {
            animation: crtPowerOff 1.5s ease-in forwards;
        }
        
        @keyframes crtPowerOn {
            0% {
                transform: scale(0.01);
                opacity: 0;
                filter: brightness(0) contrast(0);
            }
            20% {
                transform: scale(0.1);
                opacity: 0.1;
                filter: brightness(0.1) contrast(0.1);
            }
            50% {
                transform: scale(0.5);
                opacity: 0.5;
                filter: brightness(0.5) contrast(0.5);
            }
            80% {
                transform: scale(0.9);
                opacity: 0.8;
                filter: brightness(0.8) contrast(0.8);
            }
            100% {
                transform: scale(1);
                opacity: 1;
                filter: brightness(1) contrast(1);
            }
        }
        
        @keyframes crtPowerOff {
            0% {
                transform: scale(1);
                opacity: 1;
                filter: brightness(1) contrast(1);
            }
            20% {
                transform: scale(0.9);
                opacity: 0.8;
                filter: brightness(0.8) contrast(0.8);
            }
            50% {
                transform: scale(0.5);
                opacity: 0.5;
                filter: brightness(0.5) contrast(0.5);
            }
            80% {
                transform: scale(0.1);
                opacity: 0.1;
                filter: brightness(0.1) contrast(0.1);
            }
            100% {
                transform: scale(0.01);
                opacity: 0;
                filter: brightness(0) contrast(0);
            }
        }
        
        /* Visual Menu - MUTT Style */
        .visual-menu {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 17, 0, 0.95);
            border: 2px solid #33ff33;
            border-radius: 5px;
            width: 600px;
            max-width: 90vw;
            z-index: 2000;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            box-shadow: 
                0 0 50px rgba(51, 255, 51, 0.3),
                inset 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .mutt-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #33ff33;
            background: rgba(51, 255, 51, 0.1);
        }
        
        .mutt-title {
            color: #33ff33;
            font-weight: bold;
            text-shadow: 0 0 5px #33ff33;
        }
        
        .mutt-menu {
            padding: 10px 0;
        }
        
        .menu-item {
            display: flex;
            align-items: center;
            padding: 8px 15px;
            cursor: pointer;
            transition: background 0.2s ease;
            border-bottom: 1px solid rgba(51, 255, 51, 0.2);
        }
        
        .menu-item:hover {
            background: rgba(51, 255, 51, 0.1);
        }
        
        .menu-item.selected {
            background: rgba(51, 255, 51, 0.2);
        }
        
        .menu-cursor {
            color: #33ff33;
            margin-right: 10px;
            font-weight: bold;
            min-width: 10px;
            text-shadow: 0 0 3px #33ff33;
        }
        
        .menu-text {
            color: #33ff33;
            font-weight: bold;
            margin-right: 15px;
            min-width: 120px;
            text-shadow: 0 0 2px #33ff33;
        }
        
        .menu-desc {
            color: #33ff33;
            opacity: 0.8;
            font-size: 12px;
            text-shadow: 0 0 1px #33ff33;
        }
        
        .mutt-footer {
            padding: 10px 15px;
            border-top: 1px solid #33ff33;
            background: rgba(51, 255, 51, 0.05);
        }
        
        .mutt-help {
            color: #33ff33;
            font-size: 11px;
            text-align: center;
            opacity: 0.7;
            text-shadow: 0 0 2px #33ff33;
        }
        
        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: 1px solid #ff4444;
            color: #ff4444;
            cursor: pointer;
            padding: 5px 10px;
            font-family: inherit;
        }
        
        /* Matrix Screensaver */
        .matrix-screensaver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 3000;
            display: none;
        }
        
        #matrix-canvas {
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        /* Oscilloscope Screensaver */
        .oscilloscope-screensaver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 3000;
            display: none;
        }
        
        #oscilloscope-container {
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        .screensaver-text {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: #33ff33;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            text-align: center;
            text-shadow: 0 0 10px #33ff33;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .crt-monitor {
                width: 95%;
                height: 90vh;
                padding: 20px;
            }
            
            .terminal {
                font-size: 11px;
            }
            
            .menu-grid {
                grid-template-columns: 1fr;
            }
            
            .visual-menu {
                width: 90%;
                max-width: 300px;
            }
        }
        
        @media (min-width: 769px) {
            .menu-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <!-- Startup Animation -->
    <div class="startup-animation" id="startupAnimation">
        <div class="startup-text" id="startupText"></div>
    </div>
    
    <!-- Tunnel Animation -->
    <div class="tunnel-animation" id="tunnelAnimation">
        <div class="tunnel-container">
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
            <div class="tunnel-ring"></div>
        </div>
    </div>
    
    <!-- Login Screen -->
    <div class="login-screen" id="loginScreen">
        <div class="terminal">
            <div class="login-output" id="loginOutput">
                <!-- Boot messages will be added here -->
            </div>
            
            <div class="login-prompt-line">
                <span class="login-prompt">login: </span>
                <input type="text" class="login-input" id="loginInput" autofocus aria-label="Username" title="Enter username">
            </div>
            
            <div class="password-prompt-line" id="passwordPromptLine" style="display: none;">
                <span class="login-prompt">Password: </span>
                <input type="password" class="login-input" id="passwordInput" aria-label="Password" title="Enter password">
            </div>
        </div>
    </div>
    
    <!-- Terminal Screen (initially hidden) -->
    <div class="terminal-container" id="terminalContainer" style="display: none;">
        <div class="crt-monitor">
            <div class="crt-screen">
                <div class="terminal">
                    <div class="system-info">
                        <div class="logo-container">
                            <img src="logo/logogreen_nobg.png" alt="Logo" class="pulsing-logo">
                            <div class="teletype-text">SYSTEM42 ARPA</div>
                        </div>
                        <div>UNIX/32V - PDP-11/70 Compatible System</div>
                        <div>Teletype Corp. Model ASR-37 Terminal</div>
                        <div>Berkeley Software Distribution - Version 1.0</div>
                        <div>Memory: 128K words | Disk: RK05 Cartridge</div>
                        <div>Login TTY: /dev/tty03 at 300 baud</div>
                        <div>Login: Mon Aug  4 14:30:21 PDT 1975</div>
                        <div></div>
                    </div>
                    
                    <div class="terminal-output" id="output">
                        <!-- Boot messages will be dynamically added with typing effect -->
                    </div>
                    
                    <div class="prompt-line">
                        <span class="prompt" id="promptSymbol">%</span>
                        <input type="text" class="command-input" id="commandInput" autofocus placeholder="Type a command...">
                        <div class="cursor"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Matrix Screensaver -->
    <div class="matrix-screensaver" id="matrixScreensaver">
        <canvas id="matrix-canvas"></canvas>
        <div class="screensaver-text">
            <div>UNIX/32V Terminal - Press any key to continue</div>
            <div style="font-size: 12px; margin-top: 10px;">PDP-11/70 System Idle - Matrix Mode</div>
        </div>
    </div>
    
    <!-- Oscilloscope Screensaver -->
    <div class="oscilloscope-screensaver" id="oscilloscopeScreensaver">
        <div id="oscilloscope-container"></div>
        <div class="screensaver-text">
            <div>UNIX/32V Terminal - Press any key to continue</div>
            <div style="font-size: 12px; margin-top: 10px;">PDP-11/70 System Idle - Oscilloscope Mode</div>
        </div>
    </div>
    
    <!-- Canvas for CRT effects -->
    <canvas id="crt-canvas"></canvas>
    
    <!-- Matrix Follow the White Rabbit Effect -->
    <div class="matrix-overlay" id="matrixOverlay">
        <div class="matrix-text" id="matrixText"></div>
    </div>
    
    <!-- Visual Menu -->
    <div class="visual-menu" id="visualMenu">
        <div class="mutt-header">
            <div class="mutt-title">MUTT Terminal Menu v1.0</div>
            <button class="close-btn" onclick="closeVisualMenu()">[X]</button>
        </div>
        
        <div class="mutt-menu">
            <div class="menu-item" data-command="about" onclick="executeMenuCommand('about')">
                <span class="menu-cursor" id="cursor-0">></span>
                <span class="menu-text">About System</span>
                <span class="menu-desc">System information and details</span>
            </div>
            
            <div class="menu-item" data-command="projects" onclick="executeMenuCommand('projects')">
                <span class="menu-cursor" id="cursor-1"> </span>
                <span class="menu-text">Projects</span>
                <span class="menu-desc">Portfolio and work examples</span>
            </div>
            
            <div class="menu-item" data-command="contact" onclick="executeMenuCommand('contact')">
                <span class="menu-cursor" id="cursor-2"> </span>
                <span class="menu-text">Contact</span>
                <span class="menu-desc">Get in touch information</span>
            </div>
            
            <div class="menu-item" data-command="help" onclick="executeMenuCommand('help')">
                <span class="menu-cursor" id="cursor-3"> </span>
                <span class="menu-text">Help</span>
                <span class="menu-desc">Command reference and usage</span>
            </div>
            
            <!-- Admin-only networking options -->
            <div class="menu-item admin-only" data-command="ping" onclick="executeMenuCommand('ping')" style="display: none;">
                <span class="menu-cursor" id="cursor-4"> </span>
                <span class="menu-text">Ping</span>
                <span class="menu-desc">Test network connectivity</span>
            </div>
            
            <div class="menu-item admin-only" data-command="traceroute" onclick="executeMenuCommand('traceroute')" style="display: none;">
                <span class="menu-cursor" id="cursor-5"> </span>
                <span class="menu-text">Traceroute</span>
                <span class="menu-desc">Trace network path</span>
            </div>
            
            <div class="menu-item admin-only" data-command="networking" onclick="executeMenuCommand('networking')" style="display: none;">
                <span class="menu-cursor" id="cursor-6"> </span>
                <span class="menu-text">Networking</span>
                <span class="menu-desc">Network tools menu</span>
            </div>
        </div>
        
        <div class="mutt-footer">
            <div class="mutt-help">Use ↑↓ to navigate, Enter to select, ESC to close</div>
        </div>
    </div>

    <script>
        const output = document.getElementById('output');
        const commandInput = document.getElementById('commandInput');
        const visualMenu = document.getElementById('visualMenu');
        const matrixScreensaver = document.getElementById('matrixScreensaver');
        const oscilloscopeScreensaver = document.getElementById('oscilloscopeScreensaver');
        
        // Login elements
        const loginScreen = document.getElementById('loginScreen');
        const terminalContainer = document.getElementById('terminalContainer');
        const loginInput = document.getElementById('loginInput');
        const passwordInput = document.getElementById('passwordInput');
        const passwordPrompt = document.getElementById('passwordPrompt');
        
        // Typing effect variables
        let isTyping = false;
        let typeQueue = [];
        let lastActivity = Date.now();
        
        // ZShell-like prompt variables
        let currentUser = 'user';
        let currentHost = 'pdp11';
        let currentDir = '/usr/user';
        let screensaverActive = false;
        let currentScreensaver = 0; // 0 = matrix, 1 = oscilloscope
        let oscilloscopeScene, oscilloscopeCamera, oscilloscopeRenderer, oscilloscopeComposer;
        
        // Matrix screensaver variables
        let matrixScene, matrixCamera, matrixRenderer;
        let matrixColumns = [];
        let matrixGeometry, matrixMaterial, matrixMesh;
        
        // Three.js CRT Effects Setup
        let scene, camera, renderer;
        let scanlineGeometry, scanlineMaterial, scanlineMesh;
        let interferenceGeometry, interferenceMaterial, interferenceMesh;
        let time = 0;
        
        function initCRTEffects() {
            const canvas = document.getElementById('crt-canvas');
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                alpha: true,
                antialias: false 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            
            // Scanline effect
            const scanlineVertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            
            const scanlineFragmentShader = `
                uniform float time;
                uniform vec2 resolution;
                varying vec2 vUv;
                
                void main() {
                    vec2 uv = vUv;
                    
                    // Moving scanlines - thinner and less frequent
                    float scanline1 = sin((uv.y + time * 0.2) * 800.0) * 0.03;
                    float scanline2 = sin((uv.y - time * 0.15) * 600.0) * 0.02;
                    
                    // Horizontal sweep line - subtler
                    float sweepPos = mod(time * 0.1, 1.0);
                    float sweep = smoothstep(0.01, 0.0, abs(uv.y - sweepPos)) * 0.2;
                    sweep *= sin(time * 30.0) * 0.5 + 0.5; // Flickering
                    
                    // Secondary sweep - less frequent
                    float sweepPos2 = mod(time * 0.05 + 0.5, 1.0);
                    float sweep2 = smoothstep(0.005, 0.0, abs(uv.y - sweepPos2)) * 0.1;
                    sweep2 *= sin(time * 20.0 + 3.14) * 0.5 + 0.5;
                    
                    // Interference bars - less frequent and thinner
                    float interference = 0.0;
                    if (mod(time * 1.5, 10.0) < 0.5) {
                        float barPos = mod(time * 4.0, 1.0);
                        interference = smoothstep(0.01, 0.0, abs(uv.y - barPos)) * 0.2;
                        interference *= sin(time * 80.0) * 0.5 + 0.5;
                    }
                    
                    // Vertical sync issues - less frequent
                    float verticalGlitch = 0.0;
                    if (mod(time * 0.2, 15.0) < 0.2) {
                        verticalGlitch = step(0.01, sin(uv.x * 300.0 + time * 8.0)) * 0.05;
                    }
                    
                    // Phosphor decay simulation - subtler
                    float phosphor = sin(uv.y * 400.0) * 0.01;
                    
                    // Random noise - very subtle
                    float noise = fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453) * 0.01;
                    
                    float intensity = scanline1 + scanline2 + sweep + sweep2 + interference + verticalGlitch + phosphor + noise;
                    
                    gl_FragColor = vec4(0.2, 1.0, 0.2, intensity);
                }
            `;
            
            scanlineGeometry = new THREE.PlaneGeometry(2, 2);
            scanlineMaterial = new THREE.ShaderMaterial({
                vertexShader: scanlineVertexShader,
                fragmentShader: scanlineFragmentShader,
                uniforms: {
                    time: { value: 0 },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                },
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            scanlineMesh = new THREE.Mesh(scanlineGeometry, scanlineMaterial);
            scene.add(scanlineMesh);
            
            camera.position.z = 1;
        }
        
        // Matrix Screensaver Setup - High Quality
        function initMatrixScreensaver() {
            const canvas = document.getElementById('matrix-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Matrix characters (Japanese katakana, numbers, symbols)
            const matrixChars = 'ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+-=[]{}|;:,.<>?';
            
            // Matrix columns
            const columns = Math.floor(canvas.width / 20);
            const drops = [];
            
            // Initialize drops
            for (let i = 0; i < columns; i++) {
                drops[i] = {
                    y: Math.random() * -canvas.height,
                    speed: 1 + Math.random() * 2,
                    length: 10 + Math.floor(Math.random() * 20),
                    chars: [],
                    brightness: Math.random()
                };
                
                // Generate random characters for this column
                for (let j = 0; j < drops[i].length; j++) {
                    drops[i].chars[j] = matrixChars[Math.floor(Math.random() * matrixChars.length)];
                }
            }
            
            // Matrix colors
            const colors = {
                bright: '#00ff00',
                medium: '#00cc00',
                dim: '#008800',
                veryDim: '#004400'
            };
            
            function drawMatrix() {
                if (!screensaverActive) return;
                
                // Semi-transparent black overlay for fade effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw each column
                for (let i = 0; i < columns; i++) {
                    const x = i * 20;
                    const drop = drops[i];
                    
                    // Update drop position
                    drop.y += drop.speed;
                    
                    // Reset drop if it goes off screen
                    if (drop.y > canvas.height + drop.length * 20) {
                        drop.y = Math.random() * -100;
                        drop.brightness = Math.random();
                        // Regenerate characters
                        for (let j = 0; j < drop.length; j++) {
                            drop.chars[j] = matrixChars[Math.floor(Math.random() * matrixChars.length)];
                        }
                    }
                    
                    // Draw characters in this column
                    for (let j = 0; j < drop.length; j++) {
                        const charY = drop.y - j * 20;
                        
                        if (charY >= -20 && charY < canvas.height) {
                            // Calculate brightness based on position
                            let brightness = 1 - (j / drop.length);
                            brightness *= drop.brightness;
                            
                            // Add some flickering
                            brightness *= 0.8 + 0.4 * Math.random();
                            
                            // Choose color based on brightness
                            let color;
                            if (brightness > 0.8) {
                                color = colors.bright;
                            } else if (brightness > 0.5) {
                                color = colors.medium;
                            } else if (brightness > 0.2) {
                                color = colors.dim;
                            } else {
                                color = colors.veryDim;
                            }
                            
                            // Draw character
                            ctx.fillStyle = color;
                            ctx.font = '16px "Courier New", monospace';
                            ctx.fillText(drop.chars[j], x, charY);
                            
                            // Add glow effect for bright characters
                            if (brightness > 0.8) {
                                ctx.shadowColor = '#00ff00';
                                ctx.shadowBlur = 10;
                                ctx.fillText(drop.chars[j], x, charY);
                                ctx.shadowBlur = 0;
                            }
                        }
                    }
                }
                
                requestAnimationFrame(drawMatrix);
            }
            
            // Start animation
            drawMatrix();
        }
        
        function animateMatrix() {
            // Animation is now handled inside initMatrixScreensaver
            // This function is kept for compatibility
        }
        
        // Oscilloscope Screensaver Setup
        function initOscilloscopeScreensaver() {
            const container = document.getElementById('oscilloscope-container');
            
            // Clear container
            container.innerHTML = '';
            
            // Create canvas for Three.js
            const canvas = document.createElement('canvas');
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            container.appendChild(canvas);
            
            // Three.js setup
            oscilloscopeScene = new THREE.Scene();
            oscilloscopeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            oscilloscopeCamera.position.z = 8;
            
            oscilloscopeRenderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            oscilloscopeRenderer.setSize(window.innerWidth, window.innerHeight);
            oscilloscopeRenderer.setPixelRatio(window.devicePixelRatio);
            
            // Line geometry and material
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(3000 * 3);
            const colors = new Float32Array(3000 * 3);
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            const line = new THREE.Line(geometry, material);
            oscilloscopeScene.add(line);
            
            // Simple rendering without post-processing for compatibility
            oscilloscopeComposer = null;
            
            // Animation variables
            let signalTime = 0;
            let signalType = 0;
            const signalDuration = 8000;
            const points = [];
            const MAX_POINTS = 3000;
            
            const signalTypes = [
                "Sine Wave", "Square Wave", "Sawtooth Wave", 
                "Lissajous (1:2)", "Lissajous (3:2)", 
                "Lissajous (5:4)", "Damped Spiral"
            ];
            
            // Signal generation
            function getSignalPoint(t) {
                let x = 0, y = 0;
                const A = 3;
                
                switch (signalType) {
                    case 0: // Sine Wave
                        x = (t * 0.005) % (2 * Math.PI) * 2 - (2*Math.PI);
                        y = A * Math.sin(t * 0.05);
                        break;
                    case 1: // Square Wave
                        x = (t * 0.005) % (2 * Math.PI) * 2 - (2*Math.PI);
                        y = A * Math.sign(Math.sin(t * 0.05));
                        break;
                    case 2: // Sawtooth Wave
                        x = (t * 0.005) % (2 * Math.PI) * 2 - (2*Math.PI);
                        y = A * (2 * (t * 0.025 - Math.floor(0.5 + t * 0.025)));
                        break;
                    case 3: // Lissajous (1:2)
                        x = A * Math.sin(t * 0.05);
                        y = A * Math.sin(t * 0.1 + Math.PI / 2);
                        break;
                    case 4: // Lissajous (3:2)
                        x = A * Math.sin(t * 0.075);
                        y = A * Math.sin(t * 0.05);
                        break;
                    case 5: // Lissajous (5:4)
                        x = A * Math.sin(t * 0.05);
                        y = A * Math.sin(t * 0.04 + Math.PI / 3);
                        break;
                    case 6: // Damped Spiral
                        const decay = Math.exp(-t * 0.00025);
                        x = A * Math.sin(t * 0.1) * decay;
                        y = A * Math.cos(t * 0.1) * decay;
                        break;
                }
                return new THREE.Vector3(x, y, 0);
            }
            
            // Line update logic
            function updateLine() {
                const newPoint = getSignalPoint(signalTime);
                points.push(newPoint);
                if (points.length > MAX_POINTS) {
                    points.shift();
                }
                
                const positions = line.geometry.attributes.position.array;
                const colors = line.geometry.attributes.color.array;
                
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    positions[i * 3] = p.x;
                    positions[i * 3 + 1] = p.y;
                    positions[i * 3 + 2] = p.z;
                    
                    const intensity = i / (points.length - 1);
                    const color = new THREE.Color(0x00ff41);
                    color.multiplyScalar(Math.pow(intensity, 3));
                    
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                
                line.geometry.setDrawRange(0, points.length);
                line.geometry.attributes.position.needsUpdate = true;
                line.geometry.attributes.color.needsUpdate = true;
            }
            
            // Animation loop
            function animateOscilloscope() {
                if (!screensaverActive || currentScreensaver !== 1) return;
                
                requestAnimationFrame(animateOscilloscope);
                
                signalTime += 15;
                
                if (signalTime >= signalDuration) {
                    signalTime = 0;
                    signalType++;
                    if (signalType >= signalTypes.length) {
                        signalType = 0;
                    }
                    points.length = 0;
                }
                
                updateLine();
                oscilloscopeRenderer.render(oscilloscopeScene, oscilloscopeCamera);
            }
            
            // Start animation
            animateOscilloscope();
        }
        
        async function showScreensaver() {
            screensaverActive = true;
            
            try {
                // Get current screensaver status from database
                const response = await fetch('/api/screensaver/status');
                const data = await response.json();
                
                if (data.current === 'matrix') {
                    // Show matrix screensaver
                    matrixScreensaver.style.display = 'block';
                    oscilloscopeScreensaver.style.display = 'none';
                    initMatrixScreensaver();
                    currentScreensaver = 0;
                } else {
                    // Show oscilloscope screensaver
                    matrixScreensaver.style.display = 'none';
                    oscilloscopeScreensaver.style.display = 'block';
                    initOscilloscopeScreensaver();
                    currentScreensaver = 1;
                }
            } catch (error) {
                console.error('Error getting screensaver status:', error);
                // Fallback to matrix
                matrixScreensaver.style.display = 'block';
                oscilloscopeScreensaver.style.display = 'none';
                initMatrixScreensaver();
                currentScreensaver = 0;
            }
        }
        
        function hideScreensaver() {
            screensaverActive = false;
            matrixScreensaver.style.display = 'none';
            oscilloscopeScreensaver.style.display = 'none';
            lastActivity = Date.now();
        }
        
        async function switchScreensaver() {
            try {
                // Switch to next screensaver in database
                const response = await fetch('/api/screensaver/switch', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                
                if (screensaverActive) {
                    await showScreensaver();
                }
            } catch (error) {
                console.error('Error switching screensaver:', error);
                // Fallback to local switching
                currentScreensaver = (currentScreensaver + 1) % 2;
                if (screensaverActive) {
                    await showScreensaver();
                }
            }
        }
        
        function animateCRT() {
            requestAnimationFrame(animateCRT);
            
            time += 0.016; // ~60fps
            scanlineMaterial.uniforms.time.value = time;
            
            // Random screen flicker - less frequent and subtler
            if (Math.random() < 0.02) {
                scanlineMaterial.uniforms.time.value += Math.random() * 0.1;
            }
            
            // Additional random interference - less frequent
            if (Math.random() < 0.01) {
                scanlineMaterial.uniforms.time.value += Math.random() * 0.08;
            }
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            renderer.setSize(width, height);
            scanlineMaterial.uniforms.resolution.value.set(width, height);
            
            // Resize matrix canvas
            const matrixCanvas = document.getElementById('matrix-canvas');
            if (matrixCanvas) {
                matrixCanvas.width = width;
                matrixCanvas.height = height;
            }
            
            // Resize tunnel canvas
            const tunnelCanvas = document.getElementById('tunnelCanvas');
            if (tunnelCanvas) {
                tunnelCanvas.width = width;
                tunnelCanvas.height = height;
            }
            
            // Resize oscilloscope renderer
            if (oscilloscopeRenderer) {
                oscilloscopeRenderer.setSize(width, height);
                oscilloscopeCamera.aspect = width / height;
                oscilloscopeCamera.updateProjectionMatrix();
            }
        });
        
        // Commands
        const commands = {
            help: () => {
                const currentDate = new Date().toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                let helpText = `UNIX/32V Terminal - Command Reference (${currentDate})

BASIC COMMANDS:
help        menu        visual      about
projects    contact     clear       date
who         uname       ls          pwd
logout      cd          cat         echo

SYSTEM COMMANDS:
motd        matrix      oscilloscope    screensaver
history     autocomplete    commands

EMULATION COMMANDS:
run asm     run pascal  run dos     run qemu
run ssh     run help

API COMMANDS:
show api connections    show api con
show motd db

DOCUMENTATION COMMANDS:
show readme legal       show readme api
show readme emulation   show readme security
show readme performance show readme docker
show readme deployment  show readme testing

AI ASSISTANT:
Unknown commands are automatically processed by AI
Legal questions are detected and routed to legal database

AUTOCOMPLETION (Fish-style):
• Press TAB for command completion
• Use ↑↓ arrows to navigate suggestions
• Press TAB again to cycle through options
• Press ESC to cancel autocomplete
• Supports command + argument completion
• Audio feedback for different actions`;
                
                if (window.isAdmin) {
                    helpText += `

ADMIN COMMANDS:
networking   ping        traceroute  nslookup
netstat      whois       system      admin
sudo

NETWORKING TOOLS:
ping <hostname>     - Test connectivity
traceroute <host>   - Trace network path
nslookup <domain>   - DNS lookup
whois <domain>      - Domain information
netstat             - Network statistics

SYSTEM ADMIN:
system              - System information
admin               - Admin panel
sudo <command>      - Execute with privileges`;
                }
                
                helpText += `

EMULATION TOOLS:
run asm <file>      - NASM Assembler compilation
run pascal <file>   - Free Pascal compilation
run dos <command>   - DOSBox emulation
run qemu <command>  - QEMU system emulation
run ssh <command>   - SSH container access

DOCUMENTATION:
show readme legal       - Legal database integration
show readme api         - API endpoints reference
show readme emulation   - Docker emulation system
show readme security    - Security features
show readme performance - Performance optimizations
show readme docker      - Docker configuration
show readme deployment  - Deployment guide
show readme testing     - Testing procedures

USAGE EXAMPLES:
• help                    - Show this help
• ls /usr/bin            - List directory contents
• cat README             - View file contents
• ping google.com        - Test network (admin)
• history                - Show command history
• autocomplete           - Autocomplete info
• commands               - List all commands
• run asm help           - Assembler help
• run pascal help        - Pascal help
• run dos help           - DOS help
• run qemu help          - QEMU help
• run ssh help           - SSH help
• show readme legal      - Legal database docs
• show readme api        - API documentation

SPECIAL FEATURES:
• Retro CRT monitor effects
• Matrix & Oscilloscope screensavers
• Fish-style autocompletion
• Command history navigation
• AI-powered unknown command processing
• Legal database integration
• Docker emulation support
• SSH container access
• CRT-style output formatting
• Comprehensive documentation system

TOTAL COMMANDS:
${getAllAvailableCommands().length} commands available`;
                
                return helpText;
            },
            
            menu: () => {
                return `about    projects contact  visual`;
            },
            
            about: () => {
                return `UNIX/32V - Bell Telephone Laboratories
DEC PDP-11/70 (16-bit minicomputer)
Teletype Model ASR-37 Terminal
128K words core memory
RK05 disk cartridge (2.5MB)
300 baud serial connection`;
            },
            
            projects: () => {
                return `CRT Terminal Emulator
Teletype Command Parser
Phosphor Display Renderer
Retro System Interface`;
            },
            
            contact: () => {
                return `sysadmin@pdp11.bell-labs.arpa
...!ucbvax!terminal!user
user@bsd-terminal.arpa
+1-415-642-4948`;
            },
            
            visual: () => {
                showVisualMenu();
                return `Opening MUTT-style menu interface...`;
            },
            
            clear: () => {
                output.innerHTML = '';
                return '';
            },
            
            date: () => {
                const now = new Date();
                const vintage = `Mon Aug  4 14:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')} PDT 1975`;
                return vintage;
            },
            
            who: () => {
                return `user    tty03   Aug  4 14:30`;
            },
            
            uname: () => {
                return `UNIX/32V PDP-11/70`;
            },
            
            'show api connections': () => {
                return processShowApiConnections();
            },
            
            'show api con': () => {
                return processShowApiConnections();
            },
            
            ls: (args) => {
                const dirs = {
                    '/': 'bin/     etc/     usr/     var/',
                    '/usr': 'bin/     lib/     user/    include/',
                    '/usr/user': 'bin/     doc/     src/\nREADME   .profile startup',
                    '/usr/bin': 'ls       cat      echo     pwd\ncd       help     clear    date',
                    '/etc': 'passwd   hosts    fstab    motd',
                    '/var': 'log/     tmp/     spool/   cache/'
                };
                
                const targetDir = args && args.length > 0 ? args[0] : currentDir;
                const contents = dirs[targetDir] || dirs[currentDir] || 'bin/     doc/     src/\nREADME   .profile startup';
                
                return contents;
            },
            
            pwd: () => {
                return currentDir;
            },
            
            cd: (args) => {
                if (!args || args.length === 0) {
                    return `cd: usage: cd <directory>`;
                }
                
                const newDir = args[0];
                if (newDir === '..') {
                    // Go up one directory
                    const parts = currentDir.split('/');
                    if (parts.length > 2) {
                        parts.pop();
                        currentDir = parts.join('/');
                    }
                } else if (newDir === '~' || newDir === '/') {
                    // Go to home or root
                    currentDir = newDir === '~' ? '/usr/user' : '/';
                } else if (newDir.startsWith('/')) {
                    // Absolute path
                    currentDir = newDir;
                } else {
                    // Relative path
                    currentDir = currentDir.endsWith('/') ? currentDir + newDir : currentDir + '/' + newDir;
                }
                
                updatePrompt();
                return `Changed directory to: ${currentDir}`;
            },
            
            logout: () => {
                // CRT Power Off Effect
                const terminalContainer = document.getElementById('terminalContainer');
                terminalContainer.classList.add('crt-power-off');
                
                // After power off animation, show logout message and redirect
                setTimeout(() => {
                    output.innerHTML = '';
                    const logoutDiv = document.createElement('div');
                    logoutDiv.innerHTML = `<span class="error">Connection to PDP-11/70 closed by remote host.</span>
<span class="info">Use browser refresh to reconnect to terminal.</span>`;
                    output.appendChild(logoutDiv);
                    
                    // Redirect to login after showing message
                    setTimeout(() => {
                        location.reload();
                    }, 3000);
                }, 1500);
                
                return '';
            },
            
            // Admin-only networking commands
            networking: () => {
                if (!window.isAdmin) {
                    return `networking: Permission denied. Admin access required.`;
                }
                return `ping       traceroute  nslookup
netstat    whois      system
Use 'ping <host>' or 'traceroute <host>' to test connectivity.

<span class="highlight">OTHER COMMANDS:</span>
motd - Generate Bender-style message of the day
show motd db - Display MOTD database history`;
            },
            
            ping: (args) => {
                if (!window.isAdmin) {
                    return `ping: Permission denied. Admin access required.`;
                }
                if (!args || args.length === 0) {
                    return `ping: usage: ping <hostname>`;
                }
                return performPing(args[0]);
            },
            
            traceroute: (args) => {
                if (!window.isAdmin) {
                    return `traceroute: Permission denied. Admin access required.`;
                }
                if (!args || args.length === 0) {
                    return `traceroute: usage: traceroute <hostname>`;
                }
                return performTraceroute(args[0]);
            },
            
            nslookup: (args) => {
                if (!window.isAdmin) {
                    return `nslookup: Permission denied. Admin access required.`;
                }
                if (!args || args.length === 0) {
                    return `nslookup: usage: nslookup <hostname>`;
                }
                return performNslookup(args[0]);
            },
            
            netstat: (args) => {
                if (!window.isAdmin) {
                    return `netstat: Permission denied. Admin access required.`;
                }
                return performNetstat(args);
            },
            
            whois: (args) => {
                if (!window.isAdmin) {
                    return `whois: Permission denied. Admin access required.`;
                }
                if (!args || args.length === 0) {
                    return `whois: usage: whois <domain>`;
                }
                return performWhois(args[0]);
            },
            
            motd: () => {
                return performMotd();
            },
            
            'show motd db': () => {
                return performShowMotdDb();
            },
            
            system: () => {
                if (!window.isAdmin) {
                    return `system: Permission denied. Admin access required.`;
                }
                return performSystemInfo();
            },
            
            matrix: async () => {
                try {
                    await fetch('/api/screensaver/activate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ screensaver: 'matrix' })
                    });
                    await showScreensaver();
                    return `Switching to Matrix screensaver...`;
                } catch (error) {
                    console.error('Error activating matrix screensaver:', error);
                    await showScreensaver();
                    return `Switching to Matrix screensaver...`;
                }
            },
            
            oscilloscope: async () => {
                try {
                    await fetch('/api/screensaver/activate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ screensaver: 'oscilloscope' })
                    });
                    await showScreensaver();
                    return `Switching to Oscilloscope screensaver...`;
                } catch (error) {
                    console.error('Error activating oscilloscope screensaver:', error);
                    await showScreensaver();
                    return `Switching to Oscilloscope screensaver...`;
                }
            },
            
            screensaver: async () => {
                try {
                    await fetch('/api/screensaver/switch', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    await switchScreensaver();
                    return `Switching screensaver...`;
                } catch (error) {
                    console.error('Error switching screensaver:', error);
                    await switchScreensaver();
                    return `Switching screensaver...`;
                }
            },
            
            // New commands for autocompletion demo
            history: () => {
                const currentDate = new Date().toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                if (commandHistory.length === 0) {
                    return `No command history available.`;
                }
                
                const recentCommands = commandHistory.slice(0, 15);
                const totalCommands = commandHistory.length;
                
                let output = `Command History (${currentDate})

RECENT COMMANDS (${recentCommands.length}/${totalCommands}):
${recentCommands.map((cmd, index) => 
    `${String(index + 1).padStart(2, ' ')}: ${cmd}`
).join('\n')}

NAVIGATION:
• Use ↑↓ arrows to browse history
• ↑ (up arrow)    - Go to previous command
• ↓ (down arrow)  - Go to next command
• ESC             - Return to current input

HISTORY STATS:
• Total commands: ${totalCommands}
• Recent commands: ${recentCommands.length}
• History limit: 50 commands

TIPS:
• Commands are automatically saved to history
• Duplicate commands are not stored
• History persists during session`;
                
                return output;
            },
            
            autocomplete: () => {
                const currentDate = new Date().toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                return `Fish-style Autocomplete System (${currentDate})

KEYBOARD SHORTCUTS:
• TAB                    - Complete command or show suggestions
• ↑↓ Arrows             - Navigate through suggestions
• TAB (multiple)         - Cycle through options
• ESC                    - Cancel autocomplete
• ↑↓ (no suggestions)   - Navigate command history

SMART FEATURES:
• Command completion     - Type 'pi' → 'ping'
• Argument completion    - Type 'ping g' → 'ping google.com'
• Context-aware         - Different args for different commands
• Audio feedback        - Different sounds for different actions
• Visual indicators     - Green border when active

SUPPORTED COMMANDS:
• Basic: help, ls, cd, cat, echo, pwd, clear, date
• System: motd, matrix, oscilloscope, screensaver
• Admin: ping, traceroute, nslookup, whois, netstat
• API: show api connections, show motd db

AUDIO FEEDBACK:
• High tone (800-1200Hz)  - Successful completion
• Medium tone (600-800Hz) - Suggestions available
• Low tone (300-400Hz)    - No matches found

EXAMPLES:
• Type 'pi' + TAB         → 'ping'
• Type 'ping g' + TAB     → 'ping google.com'
• Type 'cat R' + TAB      → 'cat README'
• Type 'cd /u' + TAB      → 'cd /usr'

TOTAL COMMANDS:
${getAllAvailableCommands().length} commands with autocompletion support`;
            },
            
            commands: () => {
                const allCommands = getAllAvailableCommands();
                const currentDate = new Date().toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                // Categorize commands
                const basicCommands = ['help', 'menu', 'visual', 'about', 'projects', 'contact', 'clear', 'date', 'who', 'uname', 'ls', 'pwd', 'logout', 'cd', 'cat', 'echo'];
                const systemCommands = ['motd', 'matrix', 'oscilloscope', 'screensaver', 'history', 'autocomplete', 'commands'];
                const apiCommands = ['show api connections', 'show api con', 'show motd db'];
                const adminCommands = ['networking', 'ping', 'traceroute', 'nslookup', 'netstat', 'whois', 'system', 'admin', 'sudo'];
                
                let output = `UNIX/32V Terminal - Complete Command List (${currentDate})

BASIC COMMANDS (${basicCommands.length}):
${basicCommands.join(' ')}

SYSTEM COMMANDS (${systemCommands.length}):
${systemCommands.join(' ')}

API COMMANDS (${apiCommands.length}):
${apiCommands.join(' ')}

ADMIN COMMANDS (${adminCommands.length}):
${adminCommands.join(' ')}

TOTAL:
${allCommands.length} commands available

COMMAND CATEGORIES:
• Basic: File system, navigation, information
• System: Screensavers, history, utilities  
• API: Database connections and queries
• Admin: Network tools and system management

USAGE TIP:
Type partial command and press TAB for autocompletion!`;
                
                return output;
            },
            
            cat: (args) => {
                if (!args || args.length === 0) {
                    return `cat: usage: cat <filename>`;
                }
                const filename = args[0];
                const files = {
                    'README': 'UNIX/32V Terminal Emulator\nRetro PDP-11/70 Interface\n\nType "help" for available commands.',
                    '.profile': 'export PATH=/usr/bin:/usr/local/bin\nexport TERM=vt100\n# Welcome to UNIX/32V',
                    'startup': '#!/bin/sh\necho "UNIX/32V System Ready"\ndate\nwho'
                };
                return files[filename] || `cat: ${filename}: No such file or directory`;
            },
            
            echo: (args) => {
                if (!args || args.length === 0) {
                    return '';
                }
                return args.join(' ');
            },
            
            admin: () => {
                if (!window.isAdmin) {
                    return `admin: Permission denied. Admin access required.`;
                }
                return `Admin Panel Active

Admin Commands:
• networking - Network diagnostics
• system - System information  
• ping/traceroute/nslookup - Network tools
• netstat/whois - Advanced networking`;
            },
            
            sudo: (args) => {
                if (!window.isAdmin) {
                    return `sudo: Permission denied. Admin access required.`;
                }
                if (!args || args.length === 0) {
                    return `sudo: usage: sudo <command>`;
                }
                const command = args[0];
                return `Executing with elevated privileges: ${command}`;
            },
            
            'show readme legal': () => {
                return showReadmeSection('legal');
            },
            
            'show readme api': () => {
                return showReadmeSection('api');
            },
            
            'show readme emulation': () => {
                return showReadmeSection('emulation');
            },
            
            'show readme security': () => {
                return showReadmeSection('security');
            },
            
            'show readme performance': () => {
                return showReadmeSection('performance');
            },
            
            'show readme docker': () => {
                return showReadmeSection('docker');
            },
            
            'show readme deployment': () => {
                return showReadmeSection('deployment');
            },
            
            'show readme testing': () => {
                return showReadmeSection('testing');
            }
        };
        
        // Real networking functions using backend API
        async function performPing(hostname) {
            try {
                const response = await fetch('/api/ping', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ hostname })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    return data.output;
                } else {
                    return `ping: ${data.error}`;
                }
            } catch (error) {
                return `ping: ${error.message}`;
            }
        }
        
        async function performTraceroute(hostname) {
            try {
                const response = await fetch('/api/traceroute', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ hostname })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    return data.output;
                } else {
                    return `traceroute: ${data.error}`;
                }
            } catch (error) {
                return `traceroute: ${error.message}`;
            }
        }
        
        async function performNslookup(hostname) {
            try {
                const response = await fetch('/api/nslookup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ hostname })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    return data.output;
                } else {
                    return `nslookup: ${data.error}`;
                }
            } catch (error) {
                return `nslookup: ${error.message}`;
            }
        }
        
        async function performNetstat(args = []) {
            try {
                const response = await fetch('/api/netstat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ args })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    return data.output;
                } else {
                    return `netstat: ${data.error}`;
                }
            } catch (error) {
                return `netstat: ${error.message}`;
            }
        }
        
        async function performWhois(domain) {
            try {
                const response = await fetch('/api/whois', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ domain })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    return data.output;
                } else {
                    return `whois: ${data.error}`;
                }
            } catch (error) {
                return `whois: ${error.message}`;
            }
        }
        
        async function performSystemInfo() {
            try {
                const response = await fetch('/api/system');
                const data = await response.json();
                
                if (response.ok) {
                    return `Platform: ${data.platform}
Architecture: ${data.arch}
Node Version: ${data.nodeVersion}
Uptime: ${Math.floor(data.uptime)} seconds`;
                } else {
                    return `system: ${data.error}`;
                }
            } catch (error) {
                return `system: ${error.message}`;
            }
        }
        
        async function performMotd() {
            try {
                const response = await fetch('/api/motd', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({})
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    return data.output;
                } else {
                    return `motd: ${data.error}`;
                }
            } catch (error) {
                return `motd: ${error.message}`;
            }
        }

        async function performShowMotdDb() {
            try {
                const response = await fetch('/api/motd/history', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    let output = '=== MOTD Database History ===\n\n';
                    
                    if (data.history && data.history.length > 0) {
                        data.history.forEach((entry, index) => {
                            const date = new Date(entry.created_at).toLocaleString();
                            output += `${index + 1}. [${date}] [${entry.language || 'en'}] ${entry.message}\n`;
                        });
                    } else {
                        output += 'No MOTD entries found in database.\n';
                    }
                    
                    return output;
                } else {
                    return `show motd db: ${data.error}`;
                }
            } catch (error) {
                return `show motd db: ${error.message}`;
            }
        }

        async function processUnknownCommand(command) {
            try {
                const response = await fetch('/api/process-command', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        command: command,
                        isAdmin: window.isAdmin || false
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    return data.output;
                } else {
                    return `${command}: ${data.error}`;
                }
            } catch (error) {
                return `${command}: ${error.message}`;
            }
        }

        async function processShowApiConnections() {
            try {
                const response = await fetch('/api/show-api-connections', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({})
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    return data.output;
                } else {
                    return `show api connections: ${data.error}`;
                }
            } catch (error) {
                return `show api connections: ${error.message}`;
            }
        }
        
        // Autocompletion system like Fish shell
        let commandHistory = [];
        let currentHistoryIndex = -1;
        let originalInput = '';
        let autocompleteSuggestions = [];
        let currentSuggestionIndex = -1;
        let isAutocompleteActive = false;
        let lastTabTime = 0;

        // Get all available commands including admin commands
        function getAllAvailableCommands() {
            const baseCommands = [
                'help', 'menu', 'visual', 'about', 'projects', 'contact', 
                'clear', 'date', 'who', 'uname', 'ls', 'pwd', 'logout',
                'motd', 'matrix', 'oscilloscope', 'screensaver',
                'show api connections', 'show api con', 'show motd db',
                'show readme legal', 'show readme api', 'show readme emulation',
                'show readme security', 'show readme performance', 'show readme docker',
                'show readme deployment', 'show readme testing',
                'cd', 'cat', 'echo', 'history', 'autocomplete', 'commands',
                'run'
            ];
            
            const adminCommands = [
                'networking', 'ping', 'traceroute', 'nslookup', 
                'netstat', 'whois', 'system', 'admin', 'sudo'
            ];
            
            return window.isAdmin ? [...baseCommands, ...adminCommands] : baseCommands;
        }

        // Find matching commands for autocompletion
        function findMatchingCommands(partial) {
            const allCommands = getAllAvailableCommands();
            return allCommands.filter(cmd => 
                cmd.toLowerCase().startsWith(partial.toLowerCase())
            );
        }

        // Get command arguments for autocompletion
        function getCommandArguments(commandName) {
            const argsMap = {
                'ping': ['localhost', 'google.com', '8.8.8.8', 'github.com'],
                'traceroute': ['localhost', 'google.com', '8.8.8.8', 'github.com'],
                'nslookup': ['localhost', 'google.com', 'github.com', 'stackoverflow.com'],
                'whois': ['google.com', 'github.com', 'stackoverflow.com', 'example.com'],
                'cd': ['..', '~', '/', '/usr', '/usr/bin', '/etc'],
                'cat': ['README', '.profile', 'startup'],
                'ls': ['/', '/usr', '/usr/bin', '/etc', '/var'],
                'echo': ['Hello World', 'UNIX/32V', 'PDP-11/70'],
                'sudo': getAllAvailableCommands().filter(cmd => cmd !== 'sudo'),
                'run': ['asm', 'pascal', 'dos', 'qemu', 'ssh', 'help'],
                'show readme': ['legal', 'api', 'emulation', 'security', 'performance', 'docker', 'deployment', 'testing']
            };
            return argsMap[commandName] || [];
        }

        // Smart autocomplete that handles both commands and arguments with fuzzy matching
        function smartAutocomplete(input) {
            const parts = input.trim().split(/\s+/);
            
            if (parts.length === 1) {
                // Autocomplete command with fuzzy matching
                const partial = parts[0];
                const allCommands = getAllAvailableCommands();
                
                // First try exact prefix matches
                let exactMatches = allCommands.filter(cmd => 
                    cmd.toLowerCase().startsWith(partial.toLowerCase())
                );
                
                // If no exact matches, try fuzzy matching
                if (exactMatches.length === 0 && partial.length > 1) {
                    exactMatches = allCommands.filter(cmd => 
                        fuzzyMatch(cmd.toLowerCase(), partial.toLowerCase())
                    );
                }
                
                return exactMatches;
            } else if (parts.length === 2) {
                // Autocomplete argument for command
                const command = parts[0];
                const partialArg = parts[1];
                const possibleArgs = getCommandArguments(command);
                
                // Try exact matches first
                let matches = possibleArgs.filter(arg => 
                    arg.toLowerCase().startsWith(partialArg.toLowerCase())
                );
                
                // If no exact matches, try fuzzy matching
                if (matches.length === 0 && partialArg.length > 1) {
                    matches = possibleArgs.filter(arg => 
                        fuzzyMatch(arg.toLowerCase(), partialArg.toLowerCase())
                    );
                }
                
                return matches.map(arg => `${command} ${arg}`);
            } else if (parts.length === 3 && parts[0] === 'run') {
                // Autocomplete subcommand for run
                const subcommand = parts[1];
                const partialSubArg = parts[2];
                
                const runSubArgs = {
                    'asm': ['help', 'sample', 'compile', 'execute', 'hello.asm', 'add.asm', 'factorial.asm'],
                    'pascal': ['help', 'sample', 'compile', 'execute', 'hello.pas', 'calculator.pas', 'factorial.pas'],
                    'dos': ['help', 'dir', 'type', 'echo', 'cls'],
                    'qemu': ['help', 'info', 'exit'],
                    'ssh': ['help', 'ls', 'pwd', 'cd', 'cat', 'echo', 'clear']
                };
                
                const possibleSubArgs = runSubArgs[subcommand] || [];
                let matches = possibleSubArgs.filter(arg => 
                    arg.toLowerCase().startsWith(partialSubArg.toLowerCase())
                );
                
                if (matches.length === 0 && partialSubArg.length > 1) {
                    matches = possibleSubArgs.filter(arg => 
                        fuzzyMatch(arg.toLowerCase(), partialSubArg.toLowerCase())
                    );
                }
                
                return matches.map(arg => `run ${subcommand} ${arg}`);
            } else if (parts.length === 3 && parts[0] === 'show' && parts[1] === 'readme') {
                // Autocomplete documentation section
                const partialSection = parts[2];
                const sections = ['legal', 'api', 'emulation', 'security', 'performance', 'docker', 'deployment', 'testing'];
                
                let matches = sections.filter(section => 
                    section.toLowerCase().startsWith(partialSection.toLowerCase())
                );
                
                if (matches.length === 0 && partialSection.length > 1) {
                    matches = sections.filter(section => 
                        fuzzyMatch(section.toLowerCase(), partialSection.toLowerCase())
                    );
                }
                
                return matches.map(section => `show readme ${section}`);
            }
            
            return [];
        }
        
        // Fuzzy matching function for better autocomplete
        function fuzzyMatch(str, pattern) {
            let patternIndex = 0;
            for (let i = 0; i < str.length && patternIndex < pattern.length; i++) {
                if (str[i] === pattern[patternIndex]) {
                    patternIndex++;
                }
            }
            return patternIndex === pattern.length;
        }

        // Show autocomplete suggestions in Fish shell style
        function showAutocompleteSuggestions(suggestions) {
            // Remove existing suggestions
            const existingSuggestions = document.querySelectorAll('.autocomplete-container');
            existingSuggestions.forEach(el => el.remove());
            
            if (suggestions.length === 0) return;
            
            // Calculate position - move up by 2-3 lines to show above current line
            const inputRect = commandInput.getBoundingClientRect();
            const containerHeight = Math.min(suggestions.length * 25 + 40, 200); // 25px per item + header
            
            // Create suggestions container positioned above input
            const suggestionsContainer = document.createElement('div');
            suggestionsContainer.className = 'autocomplete-container';
            suggestionsContainer.style.cssText = `
                position: fixed;
                top: ${inputRect.top - containerHeight - 10}px;
                left: ${inputRect.left}px;
                background: #000;
                border: 1px solid #33ff33;
                max-height: ${containerHeight}px;
                overflow-y: auto;
                z-index: 1000;
                font-family: 'IBM Plex Mono', monospace;
                font-size: 14px;
                color: #33ff33;
                box-shadow: 
                    0 0 10px rgba(51, 255, 51, 0.3),
                    0 0 20px rgba(51, 255, 51, 0.1);
                min-width: ${Math.max(inputRect.width, 300)}px;
            `;
            
            // Add header with count and navigation info
            const headerEl = document.createElement('div');
            headerEl.className = 'autocomplete-header';
            headerEl.innerHTML = `
                <span>Suggestions (${suggestions.length}):</span>
                <span style="float: right; font-size: 12px; opacity: 0.7;">
                    TAB: cycle | ↑↓: navigate | ESC: cancel
                </span>
            `;
            headerEl.style.cssText = `
                padding: 8px 12px;
                background: #1a1a1a;
                border-bottom: 1px solid #33ff33;
                font-weight: bold;
                color: #33ff33;
                display: flex;
                justify-content: space-between;
                align-items: center;
            `;
            suggestionsContainer.appendChild(headerEl);
            
            // Create grid layout for better visual organization
            const suggestionsGrid = document.createElement('div');
            suggestionsGrid.style.cssText = `
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 1px;
                background: #1a1a1a;
            `;
            
            suggestions.forEach((suggestion, index) => {
                const suggestionEl = document.createElement('div');
                suggestionEl.className = 'autocomplete-suggestion';
                suggestionEl.textContent = suggestion;
                suggestionEl.style.cssText = `
                    padding: 8px 12px;
                    cursor: pointer;
                    background: ${index === currentSuggestionIndex ? '#1a3a1a' : 'transparent'};
                    transition: background-color 0.2s ease;
                    border-right: 1px solid #1a1a1a;
                    border-bottom: 1px solid #1a1a1a;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                `;
                
                suggestionEl.addEventListener('click', () => {
                    commandInput.value = suggestion;
                    hideAutocompleteSuggestions();
                    commandInput.focus();
                });
                
                suggestionEl.addEventListener('mouseenter', () => {
                    // Update highlighting
                    document.querySelectorAll('.autocomplete-suggestion').forEach((el, i) => {
                        el.style.background = i === index ? '#1a3a1a' : 'transparent';
                    });
                    currentSuggestionIndex = index;
                });
                
                suggestionsGrid.appendChild(suggestionEl);
            });
            
            suggestionsContainer.appendChild(suggestionsGrid);
            document.body.appendChild(suggestionsContainer);
            
            // Add visual indicator to input
            commandInput.style.borderColor = '#33ff33';
            commandInput.style.boxShadow = '0 0 5px rgba(51, 255, 51, 0.5)';
            
            // Scroll to show the container if it goes off screen
            const containerRect = suggestionsContainer.getBoundingClientRect();
            if (containerRect.top < 0) {
                suggestionsContainer.style.top = '10px';
            }
        }

        // Hide autocomplete suggestions
        function hideAutocompleteSuggestions() {
            const existingSuggestions = document.querySelectorAll('.autocomplete-container');
            existingSuggestions.forEach(el => el.remove());
            currentSuggestionIndex = -1;
            isAutocompleteActive = false;
            
            // Remove visual indicator from input
            commandInput.style.borderColor = '';
            commandInput.style.boxShadow = '';
        }

        // Apply autocomplete with Fish shell behavior
        function applyAutocomplete() {
            const input = commandInput.value;
            const suggestions = smartAutocomplete(input);
            
            if (suggestions.length === 1) {
                // Single match - complete it
                commandInput.value = suggestions[0];
                hideAutocompleteSuggestions();
                // Play completion sound
                playAutocompleteSound('complete');
            } else if (suggestions.length > 1) {
                // Multiple matches - show suggestions in Fish style
                currentSuggestionIndex = 0;
                isAutocompleteActive = true;
                autocompleteSuggestions = suggestions;
                showAutocompleteSuggestions(suggestions);
                // Play suggestion sound
                playAutocompleteSound('suggest');
                
                // Show current input with partial completion
                const commonPrefix = findCommonPrefix(suggestions);
                if (commonPrefix && commonPrefix.length > input.length) {
                    commandInput.value = commonPrefix;
                    // Position cursor at the end
                    commandInput.setSelectionRange(commonPrefix.length, commonPrefix.length);
                }
            } else {
                hideAutocompleteSuggestions();
                // Play no match sound
                playAutocompleteSound('nomatch');
            }
        }
        
        // Find common prefix for partial completion
        function findCommonPrefix(strings) {
            if (strings.length === 0) return '';
            if (strings.length === 1) return strings[0];
            
            const first = strings[0];
            let prefix = '';
            
            for (let i = 0; i < first.length; i++) {
                const char = first[i];
                for (let j = 1; j < strings.length; j++) {
                    if (strings[j][i] !== char) {
                        return prefix;
                    }
                }
                prefix += char;
            }
            
            return prefix;
        }

        // Play autocomplete sounds (using Web Audio API)
        function playAutocompleteSound(type) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch(type) {
                    case 'complete':
                        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.1);
                        break;
                    case 'suggest':
                        oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.1);
                        break;
                    case 'interrupt':
                        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
                        break;
                        oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.05);
                        break;
                    case 'nomatch':
                        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.1);
                        break;
                }
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (error) {
                // Silently fail if audio is not supported
                console.log('Audio not supported:', error);
            }
        }

        // Enhanced command input event listeners
        commandInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                e.stopPropagation();
                const command = this.value.trim();
                
                // Add to history if not empty
                if (command && !commandHistory.includes(command)) {
                    commandHistory.unshift(command);
                    if (commandHistory.length > 50) {
                        commandHistory.pop();
                    }
                }
                
                hideAutocompleteSuggestions();
                executeCommand(command);
                this.value = '';
                this.focus();
                currentHistoryIndex = -1;
                originalInput = '';
            } else if (e.key === 'Tab') {
                e.preventDefault();
                e.stopPropagation();
                
                // Check for double TAB (show all commands)
                const now = Date.now();
                if (now - lastTabTime < 300) { // Double TAB within 300ms
                    // Show all available commands
                    const allCommands = getAllAvailableCommands();
                    currentSuggestionIndex = 0;
                    isAutocompleteActive = true;
                    autocompleteSuggestions = allCommands;
                    showAutocompleteSuggestions(allCommands);
                    playAutocompleteSound('suggest');
                } else if (isAutocompleteActive && autocompleteSuggestions.length > 1) {
                    // Cycle through suggestions
                    currentSuggestionIndex = (currentSuggestionIndex + 1) % autocompleteSuggestions.length;
                    showAutocompleteSuggestions(autocompleteSuggestions);
                } else {
                    // Apply autocomplete
                    applyAutocomplete();
                }
                lastTabTime = now;
            } else if (e.key === 'Escape') {
                e.preventDefault();
                hideAutocompleteSuggestions();
                currentHistoryIndex = -1;
                originalInput = '';
            } else if (e.key === 'ArrowUp') {
                if (isAutocompleteActive && autocompleteSuggestions.length > 1) {
                    e.preventDefault();
                    currentSuggestionIndex = (currentSuggestionIndex - 1 + autocompleteSuggestions.length) % autocompleteSuggestions.length;
                    showAutocompleteSuggestions(autocompleteSuggestions);
                } else {
                    // Command history navigation
                    e.preventDefault();
                    if (currentHistoryIndex === -1) {
                        originalInput = this.value;
                    }
                    if (commandHistory.length > 0) {
                        currentHistoryIndex = Math.min(currentHistoryIndex + 1, commandHistory.length - 1);
                        this.value = commandHistory[currentHistoryIndex] || originalInput;
                    }
                }
            } else if (e.key === 'ArrowDown') {
                if (isAutocompleteActive && autocompleteSuggestions.length > 1) {
                    e.preventDefault();
                    currentSuggestionIndex = (currentSuggestionIndex + 1) % autocompleteSuggestions.length;
                    showAutocompleteSuggestions(autocompleteSuggestions);
                } else {
                    // Command history navigation
                    e.preventDefault();
                    if (currentHistoryIndex > 0) {
                        currentHistoryIndex--;
                        this.value = currentHistoryIndex === -1 ? originalInput : commandHistory[currentHistoryIndex];
                    } else if (currentHistoryIndex === 0) {
                        currentHistoryIndex = -1;
                        this.value = originalInput;
                    }
                }
            } else if (e.ctrlKey && e.key === 'c') {
                // Handle Ctrl+C to interrupt command
                e.preventDefault();
                e.stopPropagation();
                
                // Clear current input
                this.value = '';
                
                // Add interrupt message to output
                const interruptLine = document.createElement('div');
                interruptLine.className = 'output-line';
                interruptLine.innerHTML = `<span class="error">^C</span>`;
                output.appendChild(interruptLine);
                
                // Hide any active autocomplete
                hideAutocompleteSuggestions();
                currentHistoryIndex = -1;
                originalInput = '';
                
                // Play interrupt sound
                playAutocompleteSound('interrupt');
                
                // Ensure focus stays on input
                setTimeout(() => this.focus(), 10);
            } else {
                // Reset autocomplete state when typing
                if (isAutocompleteActive) {
                    hideAutocompleteSuggestions();
                }
                currentHistoryIndex = -1;
                originalInput = '';
            }
        });

        // Update autocomplete suggestions on input
        commandInput.addEventListener('input', function() {
            const input = this.value;
            if (input.trim()) {
                autocompleteSuggestions = smartAutocomplete(input);
                if (autocompleteSuggestions.length > 1) {
                    currentSuggestionIndex = 0;
                    isAutocompleteActive = true;
                    showAutocompleteSuggestions(autocompleteSuggestions);
                } else {
                    hideAutocompleteSuggestions();
                }
            } else {
                hideAutocompleteSuggestions();
            }
        });

        // Hide suggestions when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.autocomplete-container') && e.target !== commandInput) {
                hideAutocompleteSuggestions();
            }
        });
        
        commandInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                e.stopPropagation();
                const command = this.value.trim();
                executeCommand(command);
                this.value = '';
                this.focus();
            }
        });
        
        // Ensure input stays focused
        commandInput.addEventListener('blur', function() {
            setTimeout(() => this.focus(), 10);
        });
        
        function executeCommand(command) {
            lastActivity = Date.now(); // Reset activity timer
            
            // Add command to output with authentic 70s prompt
            const commandLine = document.createElement('div');
            commandLine.className = 'output-line';
            commandLine.innerHTML = `<span class="prompt">%</span> ${command}`;
            output.appendChild(commandLine);
            
            // Parse command and arguments
            const parts = command.trim().split(/\s+/);
            const commandName = parts[0].toLowerCase();
            const args = parts.slice(1);
            
            // Execute command
            let result;
            
            // First check for exact command match (including commands with spaces)
            if (commands[command]) {
                if (typeof commands[command] === 'function') {
                    result = commands[command](args);
                } else {
                    result = commands[command]();
                }
            } else if (commands[commandName]) {
                // Fallback to first word matching
                if (typeof commands[commandName] === 'function') {
                    result = commands[commandName](args);
                } else {
                    result = commands[commandName]();
                }
            } else if (commandName === '') {
                result = '';
            } else {
                // Process unknown command through AI
                result = processUnknownCommand(command);
            }
            
            if (result) {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'output-line';
                output.appendChild(resultDiv);
                
                // Handle async results
                if (result instanceof Promise) {
                    result.then(asyncResult => {
                        queueType(resultDiv, asyncResult, 30);
                    }).catch(error => {
                        queueType(resultDiv, `<span class="error">Error: ${error.message}</span>`, 30);
                    });
                } else {
                    // Type the result with delay
                    queueType(resultDiv, result, 30);
                }
                
                // Ensure scroll after adding new content
                setTimeout(() => {
                    autoScrollIfNearBottom();
                }, 50);
            }
            
            // Auto-scroll to bottom after command execution
            setTimeout(() => {
                autoScrollIfNearBottom();
            }, 100);
            
            // Close visual menu if open
            if (command !== 'visual') {
                visualMenu.style.display = 'none';
            }
        }
        
        // MUTT-style menu variables
        let currentMenuIndex = 0;
        let menuItems = [];
        
        function closeVisualMenu() {
            visualMenu.style.display = 'none';
            commandInput.focus();
            currentMenuIndex = 0;
            updateMenuCursor();
        }
        
        function executeMenuCommand(command) {
            closeVisualMenu();
            
            // Special handling for commands that need arguments
            if (command === 'ping' || command === 'traceroute') {
                const hostname = prompt(`Enter hostname for ${command}:`);
                if (hostname) {
                    executeCommand(`${command} ${hostname}`);
                }
            } else {
                executeCommand(command);
            }
        }
        
        function updateMenuCursor() {
            // Clear all cursors
            document.querySelectorAll('.menu-cursor').forEach(cursor => {
                cursor.textContent = ' ';
            });
            
            // Set current cursor
            if (menuItems[currentMenuIndex]) {
                const cursor = menuItems[currentMenuIndex].querySelector('.menu-cursor');
                if (cursor) {
                    cursor.textContent = '>';
                }
            }
        }
        
        function showVisualMenu() {
            visualMenu.style.display = 'block';
            
            // Get all visible menu items
            menuItems = Array.from(document.querySelectorAll('.menu-item:not([style*="display: none"])'));
            currentMenuIndex = 0;
            updateMenuCursor();
            
            // Show admin options if admin
            if (window.isAdmin) {
                document.querySelectorAll('.admin-only').forEach(item => {
                    item.style.display = 'flex';
                });
                menuItems = Array.from(document.querySelectorAll('.menu-item:not([style*="display: none"])'));
            }
            
            // Focus on menu for keyboard navigation
            visualMenu.focus();
        }
        
        // Keyboard navigation for MUTT menu
        document.addEventListener('keydown', function(e) {
            if (visualMenu.style.display === 'block') {
                switch(e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        currentMenuIndex = (currentMenuIndex - 1 + menuItems.length) % menuItems.length;
                        updateMenuCursor();
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        currentMenuIndex = (currentMenuIndex + 1) % menuItems.length;
                        updateMenuCursor();
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (menuItems[currentMenuIndex]) {
                            const command = menuItems[currentMenuIndex].getAttribute('data-command');
                            if (command) {
                                executeMenuCommand(command);
                            }
                        }
                        break;
                    case 'Escape':
                        e.preventDefault();
                        closeVisualMenu();
                        break;
                }
            }
        });
        
        // Smooth scrolling function
        function smoothScrollToBottom() {
            const output = document.getElementById('output');
            if (output) {
                const scrollHeight = output.scrollHeight;
                const clientHeight = output.clientHeight;
                const maxScrollTop = scrollHeight - clientHeight;
                
                // Only scroll if content is actually overflowing
                if (maxScrollTop > 0) {
                    // Smooth scroll to bottom
                    output.scrollTo({
                        top: maxScrollTop,
                        behavior: 'smooth'
                    });
                }
            }
        }
        
        // Auto-scroll function that checks if we're near the bottom
        function autoScrollIfNearBottom() {
            const output = document.getElementById('output');
            if (output) {
                const scrollTop = output.scrollTop;
                const scrollHeight = output.scrollHeight;
                const clientHeight = output.clientHeight;
                const threshold = 50; // pixels from bottom
                
                // If we're within 50 pixels of the bottom, auto-scroll
                if (scrollHeight - scrollTop - clientHeight < threshold) {
                    smoothScrollToBottom();
                }
            }
        }
        
        // Monitor DOM changes for auto-scroll
        function setupAutoScrollMonitor() {
            const output = document.getElementById('output');
            if (output) {
                // Use MutationObserver to watch for new content
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                            // New content was added, check if we should auto-scroll
                            setTimeout(() => {
                                autoScrollIfNearBottom();
                            }, 10);
                        }
                    });
                });
                
                // Start observing
                observer.observe(output, {
                    childList: true,
                    subtree: true
                });
            }
        }
        
        // Typing effect function with auto-scroll
        function queueType(element, text, speed = 30) {
            if (isTyping) {
                typeQueue.push({ element, text, speed });
                return;
            }
            
            isTyping = true;
            let index = 0;
            
            function typeChar() {
                if (index < text.length) {
                    element.innerHTML += text[index];
                    index++;
                    
                    // Auto-scroll during typing if near bottom
                    autoScrollIfNearBottom();
                    
                    setTimeout(typeChar, speed);
                } else {
                    isTyping = false;
                    
                    // Final scroll after typing is complete
                    setTimeout(smoothScrollToBottom, 50);
                    
                    if (typeQueue.length > 0) {
                        const next = typeQueue.shift();
                        queueType(next.element, next.text, next.speed);
                    }
                }
            }
            
            typeChar();
        }
        
        // Login functionality
        function handleLogin() {
            const username = loginInput.value.trim();
            if (username) {
                // Cancel Matrix effect timeout
                if (matrixTimeout) {
                    clearTimeout(matrixTimeout);
                    matrixTimeout = null;
                }
                
                // Show password prompt
                const passwordPromptLine = document.getElementById('passwordPromptLine');
                passwordPromptLine.style.display = 'flex';
                passwordInput.focus();
                
                // Check if it's admin login
                if (username.toLowerCase() === 'admin') {
                    // Admin login - will have additional privileges
                    setTimeout(() => {
                        // CRT Power Off Effect for login screen
                        loginScreen.classList.add('crt-power-off');
                        
                        setTimeout(() => {
                            loginScreen.style.display = 'none';
                            terminalContainer.style.display = 'flex';
                            initTerminal(true); // true for admin
                        }, 1500);
                    }, 1000);
                } else {
                    // Regular user login
                    setTimeout(() => {
                        // CRT Power Off Effect for login screen
                        loginScreen.classList.add('crt-power-off');
                        
                        setTimeout(() => {
                            loginScreen.style.display = 'none';
                            terminalContainer.style.display = 'flex';
                            initTerminal(false); // false for regular user
                        }, 1500);
                    }, 1000);
                }
            }
        }
        
        // Login event listeners
        loginInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleLogin();
            }
        });
        
        passwordInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                
                // Cancel Matrix effect timeout
                if (matrixTimeout) {
                    clearTimeout(matrixTimeout);
                    matrixTimeout = null;
                }
                
                // CRT Power Off Effect for login screen
                loginScreen.classList.add('crt-power-off');
                
                setTimeout(() => {
                    loginScreen.style.display = 'none';
                    terminalContainer.style.display = 'flex';
                    initTerminal();
                }, 1500);
            }
        });
        
        // Initialize login screen with boot messages
        function initLoginScreen() {
            const loginScreen = document.getElementById('loginScreen');
            
            // CRT Power On Effect for login screen
            loginScreen.classList.add('crt-power-on');
            
            // Remove power-on class after animation
            setTimeout(() => {
                loginScreen.classList.remove('crt-power-on');
            }, 2000);
            
            const loginOutput = document.getElementById('loginOutput');
            const bootMessages = [
                'UNIX/32V System Boot',
                'Bell Telephone Laboratories, Inc.',
                'Berkeley Software Distribution',
                'Memory: 128K words',
                'Disk: RK05 Cartridge',
                'TTY: /dev/tty03 at 300 baud',
                'Login: Mon Aug  4 14:30:21 PDT 1975',
                '',
                'UNIX/32V System Ready',
                ''
            ];
            
            loginOutput.innerHTML = '';
            bootMessages.forEach((msg, index) => {
                setTimeout(() => {
                    const div = document.createElement('div');
                    div.className = 'output-line' + (index === 8 ? ' success' : '');
                    loginOutput.appendChild(div);
                    queueType(div, msg, 40);
                    
                    // Auto-scroll login output
                    setTimeout(() => {
                        if (loginOutput.scrollHeight > loginOutput.clientHeight) {
                            loginOutput.scrollTo({
                                top: loginOutput.scrollHeight,
                                behavior: 'smooth'
                            });
                        }
                    }, 100);
                }, index * 600);
            });
        }
        
        // Matrix Follow the White Rabbit Effect Functions
        let matrixTimeout;
        let tunnelAnimation;
        
        function startMatrixEffect() {
            const matrixOverlay = document.getElementById('matrixOverlay');
            const matrixText = document.getElementById('matrixText');
            const loginOutput = document.getElementById('loginOutput');
            
            // Clear login output
            loginOutput.innerHTML = '';
            
            // Show matrix overlay
            matrixOverlay.style.display = 'block';
            
            // Type "Follow the white rabbit..."
            const text = "Follow the white rabbit...";
            let index = 0;
            
            function typeMatrixText() {
                if (index < text.length) {
                    matrixText.textContent += text[index];
                    index++;
                    setTimeout(typeMatrixText, 100);
                } else {
                    // Wait 2 seconds then hide matrix overlay
                    setTimeout(() => {
                        matrixOverlay.style.display = 'none';
                    }, 2000);
                }
            }
            
            typeMatrixText();
        }
        

        
                // Startup animation sequence
        let startupAnimationStarted = false;
        function startStartupAnimation() {
            if (startupAnimationStarted) {
                return; // Prevent multiple starts
            }
            startupAnimationStarted = true;
            
            const startupAnimation = document.getElementById('startupAnimation');
            const startupText = document.getElementById('startupText');
            const tunnelAnimation = document.getElementById('tunnelAnimation');
            const loginScreen = document.getElementById('loginScreen');
            
            // Show startup animation
            startupAnimation.style.display = 'flex';
            
            // Type "Follow The White Rabbit" character by character
            const message = "Follow The White Rabbit";
            let currentIndex = 0;
            
            // Show the text container first
            startupText.classList.add('visible');
            
            function typeCharacter() {
                if (currentIndex < message.length) {
                    startupText.textContent += message[currentIndex];
                    currentIndex++;
                    setTimeout(typeCharacter, 120); // 120ms delay between characters for better effect
                } else {
                    // Add dots after the message
                    setTimeout(() => {
                        startupText.textContent += ".";
                        setTimeout(() => {
                            startupText.textContent += ".";
                            setTimeout(() => {
                                startupText.textContent += ".";
                                // Wait 3 seconds after dots
                                setTimeout(() => {
                                    // Hide startup text and show tunnel
                                    startupAnimation.style.display = 'none';
                                    tunnelAnimation.style.display = 'block';
                                    
                                    // Run tunnel animation for 5 seconds
                                    setTimeout(() => {
                                        // Hide tunnel and show terminal directly
                                        tunnelAnimation.style.display = 'none';
                                        
                                        // Show terminal container directly
                                        const terminalContainer = document.getElementById('terminalContainer');
                                        terminalContainer.style.display = 'flex';
                                        
                                        // Initialize the terminal silently (without boot messages)
                                        initTerminalSilent(false);
                                        
                                        // Matrix effect removed to prevent duplicate "Follow the white rabbit" message
                                    }, 5000); // 5 seconds tunnel animation
                                }, 3000); // 3 seconds wait after dots
                            }, 500);
                        }, 500);
                    }, 500);
                }
            }
            
            // Start typing
            typeCharacter();
        }
        
        // Initialize everything
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded - Starting initialization');
            
            // Initialize CRT effects immediately for startup animation
            initCRTEffects();
            animateCRT();
            
            // Hide both login screen and terminal initially
            const loginScreen = document.getElementById('loginScreen');
            const terminalContainer = document.getElementById('terminalContainer');
            loginScreen.style.display = 'none';
            terminalContainer.style.display = 'none';
            
            // Check if this is a Command+Shift+refresh (hard refresh) or manual URL parameter
            const urlParams = new URLSearchParams(window.location.search);
            const isHardRefresh = urlParams.get('hardRefresh') === 'true';
            const isFirstVisit = !sessionStorage.getItem('hasVisited');
            
            // Set visited flag
            sessionStorage.setItem('hasVisited', 'true');
            
            if (isHardRefresh || isFirstVisit) {
                console.log('Hard refresh or first visit detected - starting full animation...');
                // Remove the parameter from URL without reloading
                const newUrl = window.location.pathname;
                window.history.replaceState({}, document.title, newUrl);
                // Start the startup animation
                startStartupAnimation();
            } else {
                console.log('Normal refresh detected - skipping animation...');
                // Skip animation and go directly to terminal
                const startupAnimation = document.getElementById('startupAnimation');
                const tunnelAnimation = document.getElementById('tunnelAnimation');
                startupAnimation.style.display = 'none';
                tunnelAnimation.style.display = 'none';
                
                // Show terminal container directly
                terminalContainer.style.display = 'flex';
                
                // Initialize the terminal silently (without boot messages)
                initTerminalSilent(false);
            }
        });
        
        // Function to update ZShell-like prompt
        function updatePrompt() {
            const promptSymbol = document.getElementById('promptSymbol');
            const symbol = window.isAdmin ? '#' : '$';
            promptSymbol.textContent = `${currentUser}@${currentHost}:${currentDir} ${symbol}`;
        }
        
        // Global keyboard event handler for refresh
        document.addEventListener('keydown', function(e) {
            // Handle Command+Shift+R for hard refresh
            if (e.metaKey && e.shiftKey && e.key === 'R') {
                e.preventDefault();
                // Add hardRefresh parameter to URL and reload
                const currentUrl = new URL(window.location);
                currentUrl.searchParams.set('hardRefresh', 'true');
                window.location.href = currentUrl.toString();
            }
            // Handle F5 or Command+R for normal refresh (ensure no hardRefresh parameter)
            if (e.key === 'F5' || (e.metaKey && e.key === 'r' && !e.shiftKey)) {
                // Remove hardRefresh parameter if it exists
                const currentUrl = new URL(window.location);
                currentUrl.searchParams.delete('hardRefresh');
                if (currentUrl.search !== window.location.search) {
                    window.history.replaceState({}, document.title, currentUrl.toString());
                }
            }
        });
        
        // Terminal initialization function (without boot messages for startup animation)
        function initTerminalSilent(isAdmin = false) {
            // Store admin status globally
            window.isAdmin = isAdmin;
            
            // Set user based on login
            currentUser = isAdmin ? 'admin' : 'user';
            
            // Update prompt
            updatePrompt();
            
            // CRT Power On Effect
            const terminalContainer = document.getElementById('terminalContainer');
            terminalContainer.style.display = 'block';
            terminalContainer.classList.add('crt-power-on');
            
            // Remove power-on class after animation
            setTimeout(() => {
                terminalContainer.classList.remove('crt-power-on');
            }, 2000);
            
            // Track user activity for screensaver
            function resetActivity() {
                lastActivity = Date.now();
                if (screensaverActive) {
                    hideScreensaver();
                }
            }
            
            // Activity listeners
            document.addEventListener('keydown', function(e) {
                // Don't reset activity for input field keydown events
                if (e.target !== commandInput) {
                    resetActivity();
                }
            });
            document.addEventListener('mousemove', resetActivity);
            document.addEventListener('click', resetActivity);
            
            // Check for screensaver every second
            setInterval(() => {
                if (Date.now() - lastActivity > 60000 && !screensaverActive) { // 60 seconds
                    showScreensaver();
                }
            }, 1000);
            
            // Switch screensavers every 30 seconds when active
            setInterval(async () => {
                if (screensaverActive) {
                    await switchScreensaver();
                }
            }, 30000);
            
            // Clear output and show ready prompt
            output.innerHTML = '';
            const readyDiv = document.createElement('div');
            readyDiv.className = 'output-line success';
            output.appendChild(readyDiv);
            queueType(readyDiv, 'UNIX/32V System Ready', 40);
            
            // Display MOTD after a short delay
            setTimeout(async () => {
                try {
                    const response = await fetch('/api/motd', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({})
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok) {
                        console.log('MOTD API response:', data);
                        console.log('MOTD output:', data.output);
                        
                        // Split the MOTD output by lines and display each line separately
                        const motdLines = data.output.split('\n');
                        console.log('MOTD lines:', motdLines);
                        
                        motdLines.forEach((line, index) => {
                            if (line.trim()) {
                                const motdDiv = document.createElement('div');
                                motdDiv.className = 'output-line motd';
                                output.appendChild(motdDiv);
                                queueType(motdDiv, line.trim(), 30);
                            }
                        });
                    } else {
                        // Fallback MOTD if API fails
                        const motdDiv = document.createElement('div');
                        motdDiv.className = 'output-line motd';
                        output.appendChild(motdDiv);
                        queueType(motdDiv, `"Bite my shiny metal ASCII! Welcome to UNIX/32V, meatbag!"`, 30);
                    }
                } catch (error) {
                    // Fallback MOTD if network fails
                    const motdDiv = document.createElement('div');
                    motdDiv.className = 'output-line motd';
                    output.appendChild(motdDiv);
                    queueType(motdDiv, `"Bite my shiny metal ASCII! Welcome to UNIX/32V, meatbag!"`, 30);
                    console.log('MOTD not available:', error.message);
                }
            }, 800); // Shorter delay for startup animation
            
            // Focus on command input and activate prompt
            setTimeout(() => {
                commandInput.focus();
                
                // Update prompt symbol for admin
                const promptSymbol = document.getElementById('promptSymbol');
                if (isAdmin) {
                    promptSymbol.textContent = '#';
                }
                
                document.addEventListener('click', () => {
                    commandInput.focus();
                });
                
                // Setup auto-scroll monitoring
                setupAutoScrollMonitor();
            }, 1200); // Wait for MOTD to finish
            
            // Additional screen effects - more frequent and varied
        }
        
        // Original terminal initialization function (with full boot messages)
        function initTerminal(isAdmin = false) {
            // Store admin status globally
            window.isAdmin = isAdmin;
            
            // Set user based on login
            currentUser = isAdmin ? 'admin' : 'user';
            
            // Update prompt
            updatePrompt();
            
            // CRT Power On Effect
            const terminalContainer = document.getElementById('terminalContainer');
            terminalContainer.style.display = 'block';
            terminalContainer.classList.add('crt-power-on');
            
            // Remove power-on class after animation
            setTimeout(() => {
                terminalContainer.classList.remove('crt-power-on');
            }, 2000);
            
            // Track user activity for screensaver
            function resetActivity() {
                lastActivity = Date.now();
                if (screensaverActive) {
                    hideScreensaver();
                }
            }
            
            // Activity listeners
            document.addEventListener('keydown', function(e) {
                // Don't reset activity for input field keydown events
                if (e.target !== commandInput) {
                    resetActivity();
                }
            });
            document.addEventListener('mousemove', resetActivity);
            document.addEventListener('click', resetActivity);
            
            // Check for screensaver every second
            setInterval(() => {
                if (Date.now() - lastActivity > 60000 && !screensaverActive) { // 60 seconds
                    showScreensaver();
                }
            }, 1000);
            
            // Initial boot sequence with typing effect
            const bootMessages = [
                isAdmin ? 'UNIX/32V System Ready (ADMIN MODE)' : 'UNIX/32V System Ready',
                ''
            ];
            
            output.innerHTML = '';
            bootMessages.forEach((msg, index) => {
                setTimeout(() => {
                    const div = document.createElement('div');
                    div.className = 'output-line' + (index === 0 ? ' success' : '');
                    output.appendChild(div);
                    queueType(div, msg, 40);
                }, index * 800);
            });
            
            // Display MOTD after boot sequence
            setTimeout(async () => {
                try {
                    const response = await fetch('/api/motd', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({})
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok) {
                        // Split the MOTD output by lines and display each line separately
                        const motdLines = data.output.split('\n');
                        motdLines.forEach((line, index) => {
                            if (line.trim()) {
                                const motdDiv = document.createElement('div');
                                motdDiv.className = 'output-line motd';
                                output.appendChild(motdDiv);
                                queueType(motdDiv, line.trim(), 30);
                            }
                        });
                    } else {
                        // Fallback MOTD if API fails
                        const motdDiv = document.createElement('div');
                        motdDiv.className = 'output-line motd';
                        output.appendChild(motdDiv);
                        queueType(motdDiv, `MOTD: "Bite my shiny metal ASCII! Welcome to UNIX/32V, meatbag!"`, 30);
                    }
                } catch (error) {
                    // Fallback MOTD if network fails
                    const motdDiv = document.createElement('div');
                    motdDiv.className = 'output-line motd';
                    output.appendChild(motdDiv);
                    queueType(motdDiv, `MOTD: "Bite my shiny metal ASCII! Welcome to UNIX/32V, meatbag!"`, 30);
                    console.log('MOTD not available:', error.message);
                }
            }, 1600); // Wait 1.6 seconds after boot messages
            
            // Additional screen effects - more frequent and varied
            setInterval(() => {
                if (Math.random() < 0.03) {
                    // Screen flicker
                    document.body.style.filter = 'brightness(1.3) contrast(0.9)';
                    setTimeout(() => {
                        document.body.style.filter = 'brightness(1) contrast(1)';
                    }, 80);
                }
            }, 500);
            
            // Additional interference effects
            setInterval(() => {
                if (Math.random() < 0.02) {
                    // Random brightness variation
                    document.body.style.filter = 'brightness(0.9) contrast(1.1)';
                    setTimeout(() => {
                        document.body.style.filter = 'brightness(1) contrast(1)';
                    }, 50);
                }
            }, 300);
            
            commandInput.focus();
            
            // Update prompt symbol for admin
            const promptSymbol = document.getElementById('promptSymbol');
            if (isAdmin) {
                promptSymbol.textContent = '#';
            }
            
            document.addEventListener('click', () => {
                commandInput.focus();
            });
            
            // Setup auto-scroll monitoring
            setupAutoScrollMonitor();
        }
        
        // Prevent context menu
        document.addEventListener('contextmenu', e => e.preventDefault());

        // README Documentation Sections
        const readmeSections = {
            legal: `## Legal Database Integration

The system includes full integration with the Ukrainian legal database "Закон Онлайн" API for searching court decisions and legal information.

### Features

- **Automatic Detection**: System automatically detects legal requests and activates search
- **Two-Stage Search**: Metadata search followed by full text retrieval
- **Query Extraction**: Intelligent extraction of search queries from Ukrainian legal text
- **Database Storage**: All search results are stored in local database
- **Statistics**: Track search history and popular queries
- **Filtering**: Search by court, judgment form, and justice kind

### Ukrainian Legal Keywords

The system recognizes Ukrainian legal terms with weights:

- **High Priority (9-10)**: житло, мешканець, реєстрація місця проживання, колишній мешканець
- **Medium Priority (7-8)**: приватизація, власник, виселення, право власності
- **Low Priority (5-6)**: адвокат, юрист, судова практика

### Usage Examples

# Search for housing-related cases
"найди судові справи про виселення з житла"

# Search for inheritance cases  
"потрібна юридична консультація щодо спадщини"

# Get court practice
"надати судову практику по житлових питаннях"

### API Configuration

To use the legal database features, set the ZAKON_TOKEN environment variable:

ZAKON_TOKEN=your_zakon_online_api_token_here`,

            api: `## API Endpoints

### Core Endpoints

- POST /api/ping - Network ping
- POST /api/traceroute - Network path tracing
- POST /api/nslookup - DNS lookup
- POST /api/whois - Domain information
- POST /api/netstat - Network statistics
- POST /api/motd - Generate MOTD
- POST /api/process-command - Process unknown commands
- GET /api/system - System information
- GET /api/health - Health check

### AI Endpoints

- POST /api/detect-legal - Detect legal requests
- POST /api/legal-search - Search legal database
- POST /api/court-cases - Process court case requests
- POST /api/tcc - Process TCC requests

### Legal Database Endpoints (Закон Онлайн)

- GET /api/zakon-online/search - Search legal database
- GET /api/zakon-online/courts - Get courts list
- GET /api/zakon-online/judgment-forms - Get judgment forms
- GET /api/zakon-online/justice-kinds - Get justice kinds
- GET /api/zakon-online/history - Search history
- GET /api/zakon-online/stats - Search statistics
- GET /api/zakon-online/top-searches - Top search queries
- GET /api/zakon-online/search/:id - Search details

### Docker Emulation Endpoints

- POST /api/docker/assembler - Compile and run assembly code
- POST /api/docker/pascal - Compile and run Pascal code
- POST /api/docker/dos - Run DOS program
- POST /api/docker/qemu - Run QEMU emulation
- GET /api/docker/files - List workspace files
- POST /api/docker/sample - Create sample program
- GET /api/docker/status - Container status

### History & Statistics

- GET /api/motd/history - MOTD history
- GET /api/openai/history - OpenAI requests history
- GET /api/commands - Available commands
- GET /api/status - AI service status`,

            emulation: `## Docker Emulation System

The system provides comprehensive emulation of classic development environments through Docker containers.

### Available Emulators

#### NASM Assembler
- **Features**: Full x86 instruction set emulation, ELF64 output format, automatic linking
- **Usage**: POST /api/docker/assembler
- **Sample**: Hello World assembly program

#### Free Pascal Compiler
- **Features**: Turbo Pascal compatibility, modern capabilities, cross-platform
- **Usage**: POST /api/docker/pascal
- **Sample**: Hello World Pascal program

#### DOSBox
- **Features**: DOS environment emulation, old games and programs support
- **Usage**: POST /api/docker/dos
- **Configuration**: Custom dosbox.conf

#### QEMU
- **Features**: Full OS emulation, multiple architectures, KVM virtualization
- **Usage**: POST /api/docker/qemu
- **Support**: FreeDOS, Linux, Windows

### Sample Programs

#### Assembly (hello.asm)
; Hello World program for NASM
section .data
    message db 'Hello, World!', 0xa
    message_length equ $ - message

section .text
    global _start

_start:
    ; Print message
    mov eax, 4          ; sys_write
    mov ebx, 1          ; stdout
    mov ecx, message    ; message
    mov edx, message_length ; length
    int 0x80

    ; Exit
    mov eax, 1          ; sys_exit
    mov ebx, 0          ; exit code 0
    int 0x80

#### Pascal (hello.pas)
program HelloWorld;
begin
    writeln('Hello, World!');
    writeln('Welcome to Free Pascal!');
end.

### Docker Configuration

services:
  retro-emulator:
    build: .
    volumes:
      - ./Emulation/workspace:/workspace
    ports:
      - "8080:8080"`,

            security: `## Security Features

### Input Validation
- Hostname and domain validation
- Command sanitization
- Malicious character detection
- Request size limits

### Rate Limiting
- General API rate limiting (100 requests per 15 minutes)
- AI-specific rate limiting (10 requests per minute)
- Configurable limits via environment variables

### Command Security
- Whitelist of allowed commands
- Argument validation
- Command timeout protection
- Buffer size limits

### CORS and Headers
- Configurable CORS origins
- Security headers (Helmet)
- Content Security Policy
- HSTS headers

### Security Notes

- The server executes system commands with the same privileges as the Node.js process
- Only use on trusted networks
- Commands have configurable timeout to prevent hanging
- All inputs are validated and sanitized
- Rate limiting prevents abuse
- Comprehensive logging for security monitoring`,

            performance: `## Performance Optimizations

### Caching
- Network command results cached for 5-60 minutes
- AI responses cached for 10-60 minutes
- Configurable cache TTL
- Automatic cache cleanup

### Database Optimization
- Connection pooling
- Prepared statements
- Indexed queries
- Efficient data storage

### Logging
- Structured JSON logging
- Separate log files for different concerns
- Log rotation and size limits
- Performance monitoring

### Monitoring

#### Health Checks
curl http://localhost:3000/api/health

#### System Information
curl http://localhost:3000/api/system

#### Legal Database Statistics
curl http://localhost:3000/api/zakon-online/stats`,

            docker: `## Docker Support

### Production Setup

1. Set environment variables
2. Configure SSL certificates
3. Set up reverse proxy (nginx)
4. Configure logging
5. Set up monitoring

### Docker Commands

# Build image
docker build -t retro-terminal .

# Run container
docker run -p 3000:3000 retro-terminal

### Docker Configuration

The system provides comprehensive emulation of classic development environments through Docker containers.

### Available Emulators

#### NASM Assembler
- **Features**: Full x86 instruction set emulation, ELF64 output format, automatic linking
- **Usage**: POST /api/docker/assembler
- **Sample**: Hello World assembly program

#### Free Pascal Compiler
- **Features**: Turbo Pascal compatibility, modern capabilities, cross-platform
- **Usage**: POST /api/docker/pascal
- **Sample**: Hello World Pascal program

#### DOSBox
- **Features**: DOS environment emulation, old games and programs support
- **Usage**: POST /api/docker/dos
- **Configuration**: Custom dosbox.conf

#### QEMU
- **Features**: Full OS emulation, multiple architectures, KVM virtualization
- **Usage**: POST /api/docker/qemu
- **Support**: FreeDOS, Linux, Windows`,

            deployment: `## Deployment

### Production Setup

1. Set environment variables
2. Configure SSL certificates
3. Set up reverse proxy (nginx)
4. Configure logging
5. Set up monitoring

### Environment Variables

| Variable | Default | Description |
|----------|---------|-------------|
| PORT | 3000 | Server port |
| NODE_ENV | development | Environment |
| OPENAI_API_KEY | - | OpenAI API key |
| RATE_LIMIT_MAX | 100 | Max requests per window |
| RATE_LIMIT_WINDOW | 900000 | Rate limit window (ms) |
| COMMAND_TIMEOUT | 10000 | Command execution timeout |
| MAX_BUFFER_SIZE | 1048576 | Max command output size |
| CACHE_TTL | 300 | Cache time-to-live (seconds) |
| LOG_LEVEL | info | Logging level |

### Database Configuration

The application uses SQLite for data storage with the following tables:
- motd_history - MOTD messages and prompts
- openai_requests - AI request history
- command_logs - Command execution logs
- security_events - Security event tracking

### Troubleshooting

#### Common Issues

1. **Port already in use:**
   # Change port in .env file
   PORT=3001

2. **Network tools not found:**
   - Windows: Install Windows Subsystem for Linux (WSL)
   - macOS: Install via Homebrew: brew install traceroute
   - Linux: Install via package manager

3. **Permission denied:**
   - Ensure you're logged in as admin
   - Check file permissions

4. **OpenAI API errors:**
   - Verify API key in .env file
   - Check API quota and billing
   - Ensure network connectivity

#### Network Tool Installation

##### macOS
brew install traceroute whois

##### Ubuntu/Debian
sudo apt-get install traceroute whois

##### CentOS/RHEL
sudo yum install traceroute whois`,

            testing: `## Testing

### Jest Tests
npm test

### Specific Test Files
npm test -- autocomplete.test.js
npm test -- commands.test.js
npm test -- commandExecutor.test.js

### HTML Tests
Open the HTML files in tests/html/ directory in a browser to test UI functionality.

### API Tests
Use the files in tests/api/ directory to test API endpoints.

### Test Coverage

#### Autocomplete System
- Command completion (TAB key)
- Argument completion
- Smart autocomplete with context
- Audio feedback
- Visual indicators

#### Terminal Commands
- Basic commands (help, ls, cd, cat, echo)
- System commands (motd, matrix, oscilloscope)
- Admin commands (ping, traceroute, nslookup)
- Command history
- Error handling

#### Security
- Input validation
- Command sanitization
- Permission checks
- SQL injection prevention

#### API Services
- Network tools (ping, traceroute, nslookup)
- Legal database integration
- AI command processing
- Docker emulation

### Test Environment

Tests use Jest as the testing framework with JSDOM for DOM simulation. The test environment includes:

- Mock DOM elements
- Simulated user interactions
- API endpoint mocking
- Database mocking
- Audio API mocking

### Adding New Tests

1. Create test file in appropriate subdirectory
2. Follow Jest testing patterns
3. Include comprehensive test cases
4. Test both success and error scenarios
5. Mock external dependencies
6. Add descriptive test names

### Test Maintenance

- Run tests before committing changes
- Update tests when adding new features
- Ensure all tests pass before deployment
- Keep test files organized and documented`
        };

        // Function to show README sections
        function showReadmeSection(section) {
            const content = readmeSections[section];
            if (!content) {
                return `Error: Section '${section}' not found in documentation.
Available sections: legal, api, emulation, security, performance, docker, deployment, testing`;
            }
            
            return `=== README SECTION: ${section.toUpperCase()} ===

${content}

=== END OF SECTION ===
Type 'help' for full command reference.`;
        }
    </script>
</body>
</html>